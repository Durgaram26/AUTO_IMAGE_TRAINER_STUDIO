{% extends "base.html" %}

{% block title %}Annotate - Griffonder{% endblock %}

{% block content %}
<div class="annotation-container">
    <!-- Main Content -->
    <div class="main-content">
        <!-- Action Bar -->
        <div class="action-bar">
            <div class="action-bar-left">
                <h2 class="page-title">Images</h2>
                <div class="action-filters">
                    <div class="filter-item">
                        <span>Status:</span>
                        <select class="filter-select" id="status-filter">
                            <option value="all">All</option>
                            <option value="annotated">Annotated</option>
                            <option value="unannotated">Not Annotated</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <span>Sort by:</span>
                        <select class="filter-select" id="sort-filter">
                            <option value="recent">Recent</option>
                            <option value="oldest">Oldest</option>
                            <option value="name">Name</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="action-bar-right">
                <div class="search-container">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" placeholder="Search images..." class="search-input" id="image-search">
                </div>
                <button class="btn btn-outline-primary" id="apply-filter-btn"><i class="fas fa-filter"></i> Filter</button>
                <button class="btn btn-outline-primary" id="batch-ai-label-btn"><i class="fas fa-robot"></i> AI Label</button>
                <button class="btn btn-primary" id="add-to-dataset-btn"><i class="fas fa-plus"></i> Add to Dataset</button>
            </div>
        </div>
        
        <!-- Progress Summary -->
        <div class="progress-summary">
            <div class="progress-metrics">
                <div class="metric-box">
                    <div class="metric-value">{{ project.images|length }}</div>
                    <div class="metric-label">Total Images</div>
                </div>
                {% set annotated_count = 0 %}
                {% for img in images %}
                    {% if img.annotations|length > 0 %}
                        {% set annotated_count = annotated_count + 1 %}
                    {% endif %}
                {% endfor %}
                <div class="metric-box">
                    <div class="metric-value">{{ annotated_count }}</div>
                    <div class="metric-label">Annotated</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">{{ images|length - annotated_count }}</div>
                    <div class="metric-label">Not Annotated</div>
                </div>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar">
                    <div class="progress-fill" style="width: {{ (annotated_count / project.images|length * 100) if project.images|length > 0 else 0 }}%"></div>
                </div>
                <div class="progress-percentage">{{ ((annotated_count / project.images|length * 100) if project.images|length > 0 else 0) | int }}% Complete</div>
            </div>
        </div>
        
        <!-- Image Grid -->
        <div class="image-grid">
            {% for image in images %}
            <div class="image-card {% if image.id == current_image.id %}selected{% endif %}" data-image-id="{{ image.id }}">
                <div class="image-container">
                    <img src="{{ url_for('get_image', filename=image.filename) }}" alt="{{ image.original_filename }}">
                    <div class="image-overlay">
                        <button class="image-action-btn annotate-btn"><i class="fas fa-pen"></i></button>
                        <button class="image-action-btn delete-btn"><i class="fas fa-trash"></i></button>
                    </div>
                    {% if image.annotations|length > 0 %}
                        <div class="status-badge annotated">
                            <i class="fas fa-check-circle"></i> Annotated
                        </div>
                    {% else %}
                        <div class="status-badge not-annotated">
                            <i class="fas fa-clock"></i> Not Annotated
                        </div>
                    {% endif %}
                </div>
                <div class="image-info">
                    <div class="image-filename">{{ image.original_filename }}</div>
                    <div class="image-meta">
                        <span class="image-date">{{ image.uploaded_at.strftime('%m/%d/%y') }}</span>
                        <div>
                            {% if image.annotations|length > 0 %}
                                <span class="annotation-count"><i class="fas fa-tag"></i> {{ image.annotations|length }}</span>
                            {% endif %}
                            {% if image.split %}
                                <span class="split-badge" data-split="{{ image.split }}">{{ image.split|capitalize }}</span>
                            {% endif %}
                        </div>
                    </div>
                </div>
                <div class="image-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: {{ 100 if image.annotations|length > 0 else 0 }}%"></div>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>

    <!-- Image Labeling Modal (hidden by default) -->
    <div id="annotation-modal" class="annotation-modal" style="display: none;" data-project-id="{{ project.id }}">
        <div class="annotation-header">
            <div class="annotation-nav">
                <button class="nav-btn" id="prev-image-btn"><i class="fas fa-chevron-left"></i></button>
                <span>Image <span id="current-image-pos">{{ image_position }}</span> of <span id="total-images">{{ image_count }}</span></span>
                <button class="nav-btn" id="next-image-btn"><i class="fas fa-chevron-right"></i></button>
            </div>
            <div class="annotation-actions">
                <div class="history-controls">
                    <button class="action-btn-icon" id="undo-btn" title="Undo"><i class="fas fa-undo"></i></button>
                    <button class="action-btn-icon" id="redo-btn" title="Redo"><i class="fas fa-redo"></i></button>
                </div>

                <div class="zoom-controls">
                    <button class="action-btn-icon" id="zoom-out-btn" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
                    <span id="zoom-level">100%</span>
                    <button class="action-btn-icon" id="zoom-in-btn" title="Zoom In"><i class="fas fa-search-plus"></i></button>
                    <button class="action-btn-icon" id="fit-screen-btn" title="Fit to Screen"><i class="fas fa-expand"></i></button>
                </div>
                <button class="action-btn" id="save-btn"><i class="fas fa-save"></i> Save</button>
                <button class="action-btn" id="close-annotation-btn"><i class="fas fa-times"></i> Close</button>
            </div>
        </div>
        
        <div class="annotation-content">
            <div class="tools-panel">
                <div class="tools-header">
                    <h3>Tools</h3>
                </div>
                <div class="tool-buttons">
                    <button class="tool-btn active" data-tool="select" title="Select Tool"><i class="fas fa-mouse-pointer"></i></button>
                    <button class="tool-btn" data-tool="hand" title="Move Tool"><i class="fas fa-hand-paper"></i></button>
                    <button class="tool-btn" data-tool="box" title="Bounding Box"><i class="fas fa-vector-square"></i></button>
                    <button class="tool-btn" data-tool="polygon" title="Polygon"><i class="fas fa-draw-polygon"></i></button>
                    <button class="tool-btn" data-tool="freehand" title="Freehand"><i class="fas fa-pen"></i></button>
                </div>
                <div class="tool-options">
                    <div class="tool-option" id="box-options">
                        <label>Box Options</label>
                        <div class="option-controls">
                            <button class="option-btn" id="lock-aspect-ratio" title="Lock Aspect Ratio"><i class="fas fa-lock"></i></button>
                            <button class="option-btn" id="snap-to-grid" title="Snap to Grid"><i class="fas fa-border-all"></i></button>
                        </div>
                    </div>
                    <div class="tool-option" id="polygon-options" style="display: none;">
                        <label>Polygon Options</label>
                        <div class="option-controls">
                            <button class="option-btn" id="close-path" title="Close Path"><i class="fas fa-unlink"></i></button>
                            <button class="option-btn" id="smooth-path" title="Smooth Edges"><i class="fas fa-sliders-h"></i></button>
                        </div>
                    </div>
                </div>
                <div class="class-list">
                    <h3>Classes</h3>
                    {% for class in classes %}
                    <div class="class-item" data-class-id="{{ class.id }}">
                        <div class="class-color" style="background-color: {{ class.color }}"></div>
                        <div class="class-name">{{ class.name }}</div>
                        <div class="remove-class" title="Remove Class"><i class="fas fa-times"></i></div>
                    </div>
                    {% endfor %}
                    <button class="add-class-btn" id="add-class-btn"><i class="fas fa-plus"></i> Add Class</button>
                </div>
            </div>
            
            <div class="image-workspace">
                <div class="image-container" id="image-canvas-container">
                    <img id="annotation-image" src="{{ url_for('get_image', filename=current_image.filename) }}" alt="{{ current_image.original_filename }}">
                    <canvas id="annotation-canvas"></canvas>
                    <div class="workspace-overlay">
                        <div class="image-controls">
                            <div class="control-group">
                                <button class="control-btn" id="reset-view" title="Reset View"><i class="fas fa-sync"></i></button>
                                <button class="control-btn" id="toggle-grid" title="Toggle Grid"><i class="fas fa-th"></i></button>
                                <button class="control-btn" id="center-at-point" title="Center at (223, 323)"><i class="fas fa-crosshairs"></i></button>
                            </div>
                            <!-- AI Labeling Controls -->
                            <div class="control-group ai-controls-group">
                                <button class="control-btn ai-control" id="ai-label-toggle" title="AI Labeling"><i class="fas fa-robot"></i></button>
                                <div class="ai-labeling-panel" id="ai-labeling-panel" style="display: none; position: fixed; top: 60px; right: 60px; z-index: 99999;">
                                    <div class="ai-panel-header">
                                        <h3>AI Labeling</h3>
                                    </div>
                                    <div class="ai-options">
                                        <div class="ai-option">
                                            <label>Mode:</label>
                                            <select id="canvas-ai-mode">
                                                <option value="detect">Object Detection</option>
                                                <option value="classify">Image Classification</option>
                                            </select>
                                        </div>
                                        <div class="ai-option">
                                            <label>Confidence: <span id="canvas-confidence-value">0.5</span></label>
                                            <input type="range" id="canvas-ai-confidence" min="0.1" max="0.9" step="0.1" value="0.5">
                                        </div>
                                        <div class="ai-option">
                                            <label>Classes:</label>
                                            <div class="selected-classes">
                                                {% for class in classes %}
                                                <div class="selected-class" data-class-id="{{ class.id }}">
                                                    <div class="class-color" style="background-color: {{ class.color }}"></div>
                                                    <div class="class-name">{{ class.name }}</div>
                                                </div>
                                                {% endfor %}
                                            </div>
                                            <div class="custom-classes-option">
                                                <label><input type="checkbox" id="use-custom-classes"> Use custom classes</label>
                                                <textarea id="canvas-custom-classes" placeholder="Enter class names, one per line" disabled></textarea>
                                            </div>
                                        </div>
                                        <div class="ai-option">
                                            <label>Scope:</label>
                                            <select id="canvas-ai-scope">
                                                <option value="current">Current image only</option>
                                                <option value="all">All images</option>
                                                <option value="unannotated">Unannotated images only</option>
                                            </select>
                                        </div>
                                        <div class="ai-action">
                                            <button class="ai-action-btn" id="run-canvas-ai"><i class="fas fa-magic"></i> Detect Objects</button>
                                        </div>
                                        <div id="ai-processing-status" class="ai-processing-status" style="display: none;">
                                            <div class="processing-progress">
                                                <div class="progress-bar">
                                                    <div id="batch-progress-bar" class="progress-fill" style="width: 0%"></div>
                                                </div>
                                                <div class="progress-text">Processing: <span id="batch-progress-count">0/0</span></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="annotations-panel">
                <div class="annotations-header">
                    <h3>Annotations</h3>
                    <div class="annotations-actions">
                        <button class="btn btn-sm" id="clear-all-btn" title="Delete All"><i class="fas fa-trash"></i></button>
                        <button class="btn btn-sm" id="export-annotations-btn" title="Export"><i class="fas fa-file-export"></i></button>
                    </div>
                </div>
                
                <!-- Dataset Split Controls -->
                <div class="dataset-split-controls">
                    <div class="split-header">
                        <h4>Dataset Split</h4>
                    </div>
                    <div class="split-options">
                        <button class="split-btn train-btn" id="train-split-btn" data-split="train">Train</button>
                        <button class="split-btn val-btn" id="val-split-btn" data-split="val">Validation</button>
                        <button class="split-btn test-btn" id="test-split-btn" data-split="test">Test</button>
                    </div>
                </div>
                
                <div class="annotations-list" id="annotations-list">
                    <!-- Annotations will be populated here via JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Dataset Split Modal -->
    <div id="dataset-split-modal" class="dataset-split-modal" style="display: none;">
        <div class="dataset-split-modal-content" style="width: 80%; max-width: 900px;">
            <h3>Add Images to Dataset Split</h3>
            <p>Select images and choose which dataset split to assign them to</p>
            
            <div class="dataset-image-selection">
                <div class="selection-controls">
                    <div class="selection-actions">
                        <button class="selection-btn" id="select-all-btn"><i class="fas fa-check-square"></i> Select All</button>
                        <button class="selection-btn" id="deselect-all-btn"><i class="fas fa-square"></i> Deselect All</button>
                        <button class="selection-btn" id="select-annotated-btn"><i class="fas fa-tag"></i> Select Annotated</button>
                        <button class="selection-btn" id="select-unannotated-btn"><i class="fas fa-clock"></i> Select Unannotated</button>
                    </div>
                    <div class="split-selection">
                        <span>Assign selected to:</span>
                        <div class="split-buttons inline">
                            <button class="split-btn train-btn active" data-split="train">Training (70%)</button>
                            <button class="split-btn val-btn" data-split="val">Validation (20%)</button>
                            <button class="split-btn test-btn" data-split="test">Testing (10%)</button>
                        </div>
                        <button class="btn btn-primary" id="apply-split-btn">Apply Split</button>
                    </div>
                </div>
                
                <div class="auto-split-section">
                    <button class="auto-split-btn" id="auto-split-btn">
                        <i class="fas fa-random"></i> Auto Split Dataset
                    </button>
                    <div class="auto-split-info">
                        Automatically distribute images using standard 70%/20%/10% split ratio for Train/Validation/Test
                    </div>
                </div>
                
                <div class="dataset-selection-stats">
                    <div class="stat-item">
                        <span class="stat-label">Selected:</span>
                        <span class="stat-value" id="selected-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total:</span>
                        <span class="stat-value" id="total-count">0</span>
                    </div>
                </div>
                
                <div class="dataset-image-grid">
                    <!-- Images will be populated here via JavaScript -->
                </div>
            </div>
            
            <div class="split-actions">
                <button class="btn dialog-btn-cancel" id="close-dataset-modal-btn">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Batch AI Labeling Modal -->
    <div id="batch-ai-modal" class="modal" style="display: none;">
        <div class="modal-content" style="width: 80%; max-width: 600px;">
            <h3>Batch AI Labeling</h3>
            <p>Automatically annotate images using zero-shot AI models</p>
            
            <div class="ai-batch-options">
                <div class="option-group">
                    <label for="batch-ai-mode">Labeling Mode:</label>
                    <select id="batch-ai-mode">
                        <option value="classify">Image Classification</option>
                        <option value="detect">Object Detection</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="batch-ai-confidence">Confidence Threshold:</label>
                    <div class="slider-with-value">
                        <input type="range" id="batch-ai-confidence" min="0.1" max="0.9" step="0.1" value="0.5">
                        <span id="batch-ai-confidence-value">0.5</span>
                    </div>
                </div>
                
                <div class="option-group">
                    <label for="batch-ai-classes">Custom Classes (optional):</label>
                    <textarea id="batch-ai-classes" placeholder="Enter class names, one per line. Leave empty to use project classes."></textarea>
                </div>
                
                <div class="option-group">
                    <label class="checkbox-container">
                        <input type="checkbox" id="replace-existing-annotations" checked>
                        <span class="checkmark"></span>
                        Replace existing annotations
                    </label>
                </div>
                
                <div class="option-group">
                    <label>Images to Process:</label>
                    <div class="image-selection-options">
                        <label class="radio-container">
                            <input type="radio" name="image-selection" id="process-unannotated" checked>
                            <span class="radio-mark"></span>
                            Unannotated images only
                        </label>
                        <label class="radio-container">
                            <input type="radio" name="image-selection" id="process-selected">
                            <span class="radio-mark"></span>
                            Selected images only
                        </label>
                        <label class="radio-container">
                            <input type="radio" name="image-selection" id="process-all">
                            <span class="radio-mark"></span>
                            All images
                        </label>
                    </div>
                </div>
            </div>
            
            <div id="batch-progress-container" style="display: none;">
                <div class="progress-label">Processing images... <span id="batch-progress-count">0/0</span></div>
                <div class="progress-bar">
                    <div id="batch-progress-bar" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn btn-secondary" id="cancel-batch-ai">Cancel</button>
                <button class="btn btn-primary" id="start-batch-ai"><i class="fas fa-robot"></i> Start Labeling</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block additional_head %}
<!-- Disable browser zoom -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
    /* Main Layout */
    .annotation-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        background-color: #f8f9fa;
        touch-action: none; /* Disable browser touch actions */
    }
    
    .main-content {
        flex: 1;
        padding: 24px;
        overflow-y: auto;
    }
    
    /* Cursor Indicator */
    .cursor-indicator {
        position: absolute;
        pointer-events: none;
        z-index: 30;
        display: none;
    }
    
    .crosshair-h, .crosshair-v {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.7);
    }
    
    .crosshair-h {
        height: 1px;
        width: 20px;
        left: -10px;
        top: 0;
    }
    
    .crosshair-v {
        width: 1px;
        height: 20px;
        top: -10px;
        left: 0;
    }
    
    .position-info {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        white-space: nowrap;
    }
    
    /* Enhanced cursor with full-canvas crosshair */
    .full-crosshair-h, .full-crosshair-v {
        position: absolute;
        background-color: rgba(108, 92, 231, 0.5);
        pointer-events: none;
        z-index: 25;
        display: none;
    }
    
    .full-crosshair-h {
        height: 1px;
        width: 100%;
        left: 0;
    }
    
    .full-crosshair-v {
        width: 1px;
        height: 100%;
        top: 0;
    }
    
    /* Position info tooltip */
    .position-info {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 30;
        font-family: monospace;
    }
    
    /* Annotation tooltip */
    .annotation-tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 13px;
        pointer-events: none;
        z-index: 40;
        font-weight: bold;
        display: none;
        border: 1px solid white;
    }
    
    /* Action Bar */
    .action-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 18px;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .action-bar-left {
        display: flex;
        align-items: center;
        gap: 20px;
    }
    
    .page-title {
        font-size: 26px;
        font-weight: 600;
        margin: 0;
        color: #333;
    }
    
    .action-filters {
        display: flex;
        gap: 15px;
    }
    
    .filter-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
    }
    
    .filter-select {
        padding: 6px 12px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background-color: white;
    }
    
    .action-bar-right {
        display: flex;
        align-items: center;
        gap: 12px;
    }
    
    .search-container {
        position: relative;
    }
    
    .search-icon {
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        color: #888;
    }
    
    .search-input {
        padding: 8px 12px 8px 35px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        width: 250px;
    }
    
    .btn {
        padding: 8px 16px;
        border-radius: 4px;
        font-weight: 500;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
    }
    
    .btn-outline-primary {
        background-color: white;
        border: 1px solid #6c5ce7;
        color: #6c5ce7;
    }
    
    .btn-primary {
        background-color: #6c5ce7;
        color: white;
        border: none;
    }
    
    /* Progress Summary */
    .progress-summary {
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        padding: 24px;
        margin-bottom: 28px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .progress-metrics {
        display: flex;
        gap: 20px;
    }
    
    .metric-box {
        padding: 0 20px;
        border-right: 1px solid #e0e0e0;
    }
    
    .metric-box:last-child {
        border-right: none;
    }
    
    .metric-value {
        font-size: 28px;
        font-weight: 600;
        color: #333;
    }
    
    .metric-label {
        font-size: 14px;
        color: #666;
        margin-top: 4px;
    }
    
    .progress-bar-container {
        flex: 1;
        max-width: 300px;
        margin-left: 20px;
    }
    
    .progress-bar {
        height: 10px;
        background-color: #f0f0f0;
        border-radius: 5px;
        overflow: hidden;
    }
    
    .progress-fill {
        height: 100%;
        background-color: #6c5ce7;
        transition: width 0.3s ease;
    }
    
    .progress-percentage {
        font-size: 14px;
        color: #666;
        margin-top: 5px;
        text-align: right;
    }
    
    /* Image Grid */
    .image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 15px;
        width: 100%;
        justify-content: space-between;
    }
    
    .image-card {
        background-color: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        transition: all 0.25s;
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 280px;
        margin: 0;
    }
    
    .image-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .image-card.selected {
        border: 2px solid #6c5ce7;
        box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.2);
    }
    
    /* Image Container improvements */
    .image-container {
        height: 180px;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #f5f5f5;
        overflow: hidden;
    }
    
    .image-container img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.3s ease;
    }
    
    .image-card:hover .image-container img {
        transform: scale(1.05);
    }
    
    /* Improved image info */
    .image-info {
        padding: 16px;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }
    
    .image-filename {
        font-size: 15px;
        font-weight: 500;
        color: #333;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 5px;
    }
    
    .image-meta {
        display: flex;
        justify-content: space-between;
        margin-top: 5px;
        font-size: 12px;
        color: #777;
    }
    
    .annotation-count {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    /* Split badge for thumbnails */
    .split-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: 500;
        color: white;
        margin-left: 5px;
    }
    
    .split-badge[data-split="train"] {
        background-color: #00b894;
    }
    
    .split-badge[data-split="val"] {
        background-color: #0984e3;
    }
    
    .split-badge[data-split="test"] {
        background-color: #e84393;
    }
    
    .image-progress {
        padding: 0 12px 12px 12px;
    }
    
    .image-progress .progress-bar {
        height: 4px;
    }
    
    /* Annotation Modal improvements */
    .annotation-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
        background-color: #1a1a1a;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    .annotation-header {
        padding: 16px 20px;
        background-color: #1a1a1a;
        color: white;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .annotation-nav {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .nav-btn {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: rgba(255,255,255,0.1);
        border: none;
        color: white;
        cursor: pointer;
    }
    
    .annotation-actions {
        display: flex;
        gap: 15px;
        align-items: center;
    }
    
    /* Common annotation toggle switch */
    .common-annotation-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 0 15px;
        border-right: 1px solid rgba(255,255,255,0.2);
    }
    
    .toggle-label {
        font-size: 12px;
        color: #ccc;
    }
    
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
    }
    
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #444;
        transition: .4s;
        border-radius: 20px;
    }
    
    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
        background-color: #6c5ce7;
    }
    
    input:checked + .toggle-slider:before {
        transform: translateX(20px);
    }
    
    /* Badge to indicate common annotations */
    .common-badge {
        background-color: #6c5ce7;
        color: white;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 3px;
        margin-left: 5px;
    }
    
    .history-controls, .zoom-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 0 5px;
        border-right: 1px solid rgba(255,255,255,0.2);
    }
    
    .action-btn-icon {
        width: 30px;
        height: 30px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.1);
        border: none;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
    
    .action-btn-icon:hover {
        background-color: rgba(255,255,255,0.2);
    }
    
    #zoom-level {
        min-width: 50px;
        text-align: center;
        font-size: 14px;
    }
    
    .action-btn {
        padding: 8px 15px;
        background-color: #6c5ce7;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .action-btn:hover {
        background-color: #5e4ed3;
    }
    
    .annotation-content {
        display: flex;
        flex: 1;
        overflow: hidden;
    }
    
    .tools-panel {
        width: 280px;
        background-color: #222;
        color: white;
        padding: 18px;
        overflow-y: auto;
    }
    
    .tools-header {
        margin-bottom: 15px;
    }
    
    .tool-buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 15px;
    }
    
    .tool-btn {
        padding: 12px;
        background-color: #333;
        border-radius: 6px;
        color: white;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .tool-btn.active {
        background-color: #6c5ce7;
        box-shadow: 0 0 10px rgba(108, 92, 231, 0.3);
    }
    
    .tool-btn:hover:not(.active) {
        background-color: #444;
    }
    
    .tool-options {
        background-color: #333;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 15px;
    }
    
    .tool-option label {
        display: block;
        margin-bottom: 8px;
        font-size: 14px;
        color: #bbb;
    }
    
    .option-controls {
        display: flex;
        gap: 8px;
    }
    
    .option-btn {
        width: 32px;
        height: 32px;
        border-radius: 4px;
        background-color: #444;
        border: none;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .option-btn.active {
        background-color: #6c5ce7;
    }
    
    .class-list {
        margin-top: 20px;
    }
    
    .class-item {
        display: flex;
        align-items: center;
        padding: 8px;
        margin-bottom: 5px;
        border-radius: 4px;
        cursor: pointer;
        position: relative;
    }
    
    .class-item:hover {
        background-color: #333;
    }
    
    .class-item:hover .remove-class {
        display: flex;
    }
    
    .remove-class {
        position: absolute;
        right: 5px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: #ff6b6b;
        color: white;
        font-size: 10px;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
    
    .class-color {
        width: 14px;
        height: 14px;
        border-radius: 3px;
        margin-right: 10px;
    }
    
    .class-name {
        font-size: 14px;
    }
    
    .add-class-btn {
        width: 100%;
        padding: 8px;
        background-color: #333;
        border: none;
        color: white;
        border-radius: 4px;
        margin-top: 10px;
        cursor: pointer;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .image-workspace {
        flex: 1;
        position: relative;
        overflow: hidden;
        background-color: #2a2a2a;
        display: flex;
        justify-content: center;
        align-items: center;
        touch-action: none;
        -ms-touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    .image-container {
        position: relative;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
    }
    
    .image-container img#annotation-image {
        position: absolute;
        width: 800px;
        height: 600px;
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        user-select: none;
        -webkit-user-drag: none;
        transform-origin: center center;
        z-index: 5;
    }
    
    canvas#annotation-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: all;
        margin: auto;
        right: 0;
        bottom: 0;
        z-index: 10;
        display: block;
        visibility: visible;
    }
    
    .workspace-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 20;
    }
    
    .image-controls {
        position: absolute;
        bottom: 15px;
        right: 15px;
        pointer-events: auto;
    }
    
    .control-group {
        display: flex;
        gap: 5px;
        background-color: rgba(0,0,0,0.5);
        padding: 5px;
        border-radius: 4px;
    }
    
    .control-btn {
        width: 30px;
        height: 30px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.1);
        border: none;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .control-btn:hover {
        background-color: rgba(255,255,255,0.2);
    }
    
    .annotations-panel {
        width: 280px;
        background-color: #222;
        color: white;
        padding: 18px;
        overflow-y: auto;
    }
    
    .annotations-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .annotations-actions {
        display: flex;
        gap: 5px;
    }
    
    .btn-sm {
        width: 30px;
        height: 30px;
        padding: 0;
        font-size: 12px;
        background-color: #333;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .btn-sm:hover {
        background-color: #444;
    }
    
    .annotations-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    
    .annotation-item {
        background-color: #333;
        border-radius: 6px;
        padding: 14px;
        transition: all 0.2s;
    }
    
    .annotation-item:hover {
        background-color: #3a3a3a;
    }
    
    .annotation-item.selected {
        border: 1px solid #6c5ce7;
        background-color: #393663;
    }
    
    .annotation-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }
    
    .annotation-label {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .annotation-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
    }
    
    .annotation-actions {
        display: flex;
        gap: 5px;
    }
    
    .annotation-btn {
        width: 24px;
        height: 24px;
        background-color: #444;
        border: none;
        border-radius: 3px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
    }
    
    .annotation-btn:hover {
        background-color: #555;
    }
    
    .annotation-item.selected {
        border: 1px solid #6c5ce7;
    }
    
    /* Add class dialog */
    .add-class-dialog, .dataset-split-modal-content {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #333;
        padding: 20px;
        border-radius: 8px;
        z-index: 1100;
        width: 300px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        color: white;
    }
    
    /* Dataset split modal */
    .dataset-split-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.7);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    
    .dataset-split-modal h3 {
        margin-top: 0;
        margin-bottom: 10px;
        text-align: center;
    }
    
    .dataset-split-modal p {
        margin-bottom: 20px;
        text-align: center;
        color: #ccc;
    }
    
    .split-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }
    
    .split-buttons .split-btn {
        padding: 14px;
        border-radius: 8px;
        font-weight: 600;
        font-size: 15px;
        transition: all 0.2s;
    }
    
    .split-buttons .train-btn {
        background-color: #00b894;
    }
    
    .split-buttons .val-btn {
        background-color: #0984e3;
    }
    
    .split-buttons .test-btn {
        background-color: #e84393;
    }
    
    .split-actions {
        display: flex;
        justify-content: space-between;
    }
    
    .split-actions .btn {
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background-color: #444;
        color: white;
    }
    
    .add-class-dialog h3 {
        margin-top: 0;
        margin-bottom: 15px;
    }
    
    .dialog-field {
        margin-bottom: 15px;
    }
    
    .dialog-field label {
        display: block;
        margin-bottom: 5px;
        font-size: 14px;
    }
    
    .dialog-field input[type="text"],
    .dialog-field input[type="color"] {
        width: 100%;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #444;
        background-color: #222;
        color: white;
    }
    
    .dialog-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
    }
    
    .dialog-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    
    .dialog-btn-cancel {
        background-color: #444;
        color: white;
    }
    
    .dialog-btn-confirm {
        background-color: #6c5ce7;
        color: white;
    }
    
    .dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.7);
        z-index: 1050;
    }
    
    /* Add dataset split styles */
    .dataset-split-controls {
        background-color: #333;
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 4px;
    }
    
    .split-header {
        margin-bottom: 10px;
    }
    
    .split-header h4 {
        margin: 0;
        font-size: 14px;
        color: #bbb;
    }
    
    .split-options {
        display: flex;
        gap: 5px;
    }
    
    .split-btn {
        flex: 1;
        padding: 6px 0;
        border: none;
        border-radius: 3px;
        background-color: #444;
        color: white;
        font-size: 12px;
        cursor: pointer;
    }
    
    .split-btn:hover {
        background-color: #555;
    }
    
    .split-btn.active {
        background-color: #6c5ce7;
    }
    
    .train-btn.active {
        background-color: #00b894;
    }
    
    .val-btn.active {
        background-color: #0984e3;
    }
    
    .test-btn.active {
        background-color: #e84393;
    }
    
    .split-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: bold;
        background-color: #6c5ce7;
        color: white;
        margin-left: 5px;
    }
    
    /* Dataset Split Modal Styles */
    .dataset-split-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.8);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow-y: auto;
    }
    
    .dataset-split-modal-content {
        background-color: #222;
        padding: 20px;
        border-radius: 8px;
        color: white;
        max-height: 90vh;
        overflow-y: auto;
    }
    
    .dataset-image-selection {
        margin: 20px 0;
    }
    
    .selection-controls {
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
    }
    
    .selection-actions {
        display: flex;
        gap: 10px;
    }
    
    .split-selection {
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .split-buttons.inline {
        display: flex;
        gap: 10px;
    }
    
    .split-buttons.inline .split-btn {
        padding: 8px 15px;
        font-weight: bold;
    }
    
    .dataset-image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
        margin-top: 20px;
        max-height: 50vh;
        overflow-y: auto;
        padding: 10px;
        background-color: #333;
        border-radius: 5px;
        width: 100%;
    }
    
    .dataset-image-item {
        position: relative;
        border-radius: 5px;
        overflow: hidden;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        background: #222;
        width: 100%;
        height: 160px;
    }
    
    .dataset-image-item img {
        width: 100%;
        height: 120px;
        object-fit: cover;
    }
    
    .dataset-image-info {
        padding: 5px;
        font-size: 11px;
        background-color: rgba(0,0,0,0.7);
    }
    
    .dataset-image-item .split-badge {
        position: absolute;
        top: 5px;
        right: 5px;
    }
    
    .dataset-image-item.train .split-badge {
        background-color: #00b894;
    }
    
    .dataset-image-item.val .split-badge {
        background-color: #0984e3;
    }
    
    .dataset-image-item.test .split-badge {
        background-color: #e84393;
    }
    
    /* Training page split preview styles */
    .split-preview-section {
        margin: 20px 0;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
    }
    
    .split-preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .split-preview-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 10px;
    }
    
    .split-preview-item {
        border-radius: 5px;
        overflow: hidden;
    }
    
    .split-preview-item img {
        width: 100%;
        height: 100px;
        object-fit: cover;
    }
    
    /* Enhanced selection controls */
    .selection-btn {
        background: #444;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 5px;
        transition: all 0.2s;
    }
    
    .selection-btn:hover {
        background: #555;
    }
    
    .auto-split-section {
        background: #333;
        border-radius: 5px;
        padding: 15px;
        margin: 15px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
    }
    
    .auto-split-btn {
        background: #00b894;
        color: white;
        border: none;
        border-radius: 5px;
        padding: 10px 20px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s;
    }
    
    .auto-split-btn:hover {
        background: #009b7d;
    }
    
    .auto-split-info {
        color: #ddd;
        font-size: 13px;
        max-width: 60%;
    }
    
    .dataset-selection-stats {
        background: #333;
        border-radius: 5px;
        padding: 10px 15px;
        display: flex;
        gap: 20px;
        margin-top: 15px;
    }
    
    .stat-item {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .stat-label {
        color: #aaa;
        font-size: 13px;
    }
    
    .stat-value {
        color: white;
        font-weight: bold;
        font-size: 14px;
    }
    
    /* Enhanced button styles */
    .btn {
        padding: 10px 18px;
        border-radius: 6px;
        font-weight: 500;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .btn-outline-primary {
        background-color: white;
        border: 1px solid #6c5ce7;
        color: #6c5ce7;
    }
    
    .btn-outline-primary:hover {
        background-color: #f8f5ff;
    }
    
    .btn-primary {
        background-color: #6c5ce7;
        color: white;
        border: none;
    }
    
    .btn-primary:hover {
        background-color: #5d4fd3;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(108, 92, 231, 0.2);
    }
    
    /* Status badge improvements */
    .status-badge {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 5px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        z-index: 10;
    }
    
    .status-badge.annotated {
        background-color: rgba(46, 213, 115, 0.9);
        color: white;
    }
    
    .status-badge.not-annotated {
        background-color: rgba(255, 107, 107, 0.9);
        color: white;
    }
    
    /* Image action buttons */
    .image-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 5;
        backdrop-filter: blur(2px);
    }
    
    .image-card:hover .image-overlay {
        opacity: 1;
    }
    
    .image-action-btn {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background-color: white;
        border: none;
        color: #333;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.25s;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        font-size: 16px;
    }
    
    .image-action-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.25);
    }
    
    .annotate-btn:hover {
        background-color: #6c5ce7;
        color: white;
    }
    
    .delete-btn:hover {
        background-color: #ff6b6b;
        color: white;
    }
    
    /* Search input improvements */
    .search-container {
        position: relative;
    }
    
    .search-icon {
        position: absolute;
        left: 14px;
        top: 50%;
        transform: translateY(-50%);
        color: #888;
    }
    
    .search-input {
        padding: 10px 12px 10px 40px;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        width: 260px;
        font-size: 14px;
        transition: all 0.2s;
    }
    
    .search-input:focus {
        border-color: #6c5ce7;
        box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.15);
        outline: none;
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Get DOM elements
    const annotationModal = document.getElementById('annotation-modal');
    const closeAnnotationBtn = document.getElementById('close-annotation-btn');
    const imageCards = document.querySelectorAll('.image-card');
    const annotationCanvas = document.getElementById('annotation-canvas');
    const annotationImage = document.getElementById('annotation-image');
    const imageContainer = document.getElementById('image-canvas-container');
    const filterSelect = document.querySelector('.filter-select');
    const searchInput = document.querySelector('.search-input');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const zoomInBtn = document.getElementById('zoom-in-btn');
    const zoomOutBtn = document.getElementById('zoom-out-btn');
    const fitScreenBtn = document.getElementById('fit-screen-btn');
    const resetViewBtn = document.getElementById('reset-view');
    const toggleGridBtn = document.getElementById('toggle-grid');
    const clearAllBtn = document.getElementById('clear-all-btn');
    const saveBtn = document.getElementById('save-btn');
    const exportAnnotationsBtn = document.getElementById('export-annotations-btn');
    const prevImageBtn = document.getElementById('prev-image-btn');
    const nextImageBtn = document.getElementById('next-image-btn');
    const zoomLevelDisplay = document.getElementById('zoom-level');
    const toolButtons = document.querySelectorAll('.tool-btn');
    const addClassBtn = document.getElementById('add-class-btn');
    const classItems = document.querySelectorAll('.class-item');
    
    // Variables to keep track of state
    let ctx;
    let isDrawing = false;
    let currentTool = 'select';
    let currentClass = null;
    let selectedAnnotation = null;
    let currentAnnotation = null;
    let zoomLevel = 1;
    let panX = 0;
    let panY = 0;
    let showGrid = false;
    let annotations = [];
    let history = [];
    let historyIndex = -1;
    let currentImageId = document.querySelector('.image-card.selected') ? 
        document.querySelector('.image-card.selected').dataset.imageId : 0;
    let currentImageIndex = 0;
    
    // Function to update current image index - defined early so it can be called
    function updateCurrentImageIndex() {
        imageCards.forEach((card, index) => {
            if (card.dataset.imageId === currentImageId) {
                currentImageIndex = index;
                // Update current image position in the UI
                const currentImagePos = document.getElementById('current-image-pos');
                if (currentImagePos) {
                    currentImagePos.textContent = index + 1;
                }
            }
        });
    }
    
    // Get window dimensions for responsive handling
    let windowWidth = window.innerWidth;
    let windowHeight = window.innerHeight;
    
    // Colors for different annotation types
    const colors = {
        box: '#6c5ce7',
        polygon: '#00b894',
        freehand: '#ff7675',
        selection: '#ffeaa7',
        grid: 'rgba(100, 100, 100, 0.5)'
    };
    
    // Function to setup cursor indicators
    function setupCursors() {
        console.log("Setting up cursors...");
        
        // Create crosshair elements if they don't exist
        let crosshairH = document.querySelector('.full-crosshair-h');
        let crosshairV = document.querySelector('.full-crosshair-v');
        let positionInfo = document.querySelector('.position-info');
        
        if (!crosshairH) {
            crosshairH = document.createElement('div');
            crosshairH.className = 'full-crosshair-h';
            imageContainer.appendChild(crosshairH);
        }
        
        if (!crosshairV) {
            crosshairV = document.createElement('div');
            crosshairV.className = 'full-crosshair-v';
            imageContainer.appendChild(crosshairV);
        }
        
        if (!positionInfo) {
            positionInfo = document.createElement('div');
            positionInfo.className = 'position-info';
            imageContainer.appendChild(positionInfo);
        }
        
        // Add mousemove event listener to show crosshairs
        annotationCanvas.addEventListener('mousemove', function(e) {
            const rect = annotationCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Position crosshairs
            crosshairH.style.top = `${y}px`;
            crosshairH.style.display = 'block';
            
            crosshairV.style.left = `${x}px`;
            crosshairV.style.display = 'block';
            
            // Update position info
            const imageX = Math.round((x - panX) / zoomLevel);
            const imageY = Math.round((y - panY) / zoomLevel);
            
            positionInfo.textContent = `X: ${imageX}, Y: ${imageY}`;
            positionInfo.style.left = `${x + 15}px`;
            positionInfo.style.top = `${y - 25}px`;
            positionInfo.style.display = 'block';
            
            // Check if we're hovering over an annotation while Ctrl is pressed
            if (e.ctrlKey) {
                handleCtrlHover(imageX, imageY);
            } else {
                // Reset opacity for all annotations
                resetAnnotationOpacity();
            }
        });
        
        // Hide crosshairs when mouse leaves canvas
        annotationCanvas.addEventListener('mouseleave', function() {
            crosshairH.style.display = 'none';
            crosshairV.style.display = 'none';
            positionInfo.style.display = 'none';
            resetAnnotationOpacity();
        });
        
        // Handle keydown for Ctrl key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Control' && annotationModal.style.display === 'flex') {
                const rect = annotationCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const imageX = Math.round((x - panX) / zoomLevel);
                const imageY = Math.round((y - panY) / zoomLevel);
                
                handleCtrlHover(imageX, imageY);
            }
        });
        
        // Handle keyup for Ctrl key
        document.addEventListener('keyup', function(e) {
            if (e.key === 'Control') {
                resetAnnotationOpacity();
            }
        });
    }
    
    // Function to handle Ctrl+Hover over annotations
    function handleCtrlHover(x, y) {
        let hoveredAnnotation = null;
        
        // Find if we're over an annotation
        for (let i = annotations.length - 1; i >= 0; i--) {
            if (isPointInAnnotation(x, y, annotations[i])) {
                hoveredAnnotation = annotations[i];
                break;
            }
        }
        
        if (hoveredAnnotation) {
            // Show tooltip with class name
            let tooltip = document.getElementById('annotation-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'annotation-tooltip';
                tooltip.className = 'annotation-tooltip';
                imageContainer.appendChild(tooltip);
            }
            
            // Get class name
            const className = hoveredAnnotation.class || 'Unlabeled';
            tooltip.textContent = className;
            tooltip.style.display = 'block';
            
            // Position near mouse
            const rect = annotationCanvas.getBoundingClientRect();
            tooltip.style.left = `${x * zoomLevel + panX + 15}px`;
            tooltip.style.top = `${y * zoomLevel + panY - 30}px`;
            
            // Apply highlight effect - redraw with special highlight
            drawAnnotationsWithHighlight(hoveredAnnotation);
        } else {
            // Hide tooltip if not over annotation
            const tooltip = document.getElementById('annotation-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
            
            // Reset to normal view
            resetAnnotationOpacity();
        }
    }
    
    // Function to draw annotations with one highlighted
    function drawAnnotationsWithHighlight(highlightedAnnotation) {
        if (!ctx) return;
        
        ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        
        // Draw grid if enabled
        if (showGrid) {
            drawGrid();
        }
        
        // First pass - draw a semi-transparent overlay on the entire canvas
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        
        // Second pass - draw all annotations with regular opacity
        annotations.forEach(annotation => {
            const isHighlighted = annotation === highlightedAnnotation;
            
            // If this is the highlighted annotation, use composition mode to "cut out" the overlay
            if (isHighlighted) {
                // Save context state
                ctx.save();
                // Use "destination-out" to clear the area of this annotation
                ctx.globalCompositeOperation = 'destination-out';
                
                // Draw the annotation shape to create a "hole" in the overlay
                drawAnnotationShape(annotation, false, true);
                
                // Restore context state
                ctx.restore();
            }
            
            // Now draw the actual annotation with regular styling
            drawAnnotation(annotation, annotation === selectedAnnotation);
        });
    }
    
    // Function to draw just the shape of an annotation (for masking)
    function drawAnnotationShape(annotation, isSelected, forMask = false) {
        if (!annotation) return;
        
        const scaledPoints = annotation.points.map(point => ({
            x: point.x * zoomLevel + panX,
            y: point.y * zoomLevel + panY
        }));
        
        // For mask, use fill only
        if (forMask) {
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        }
        
        switch(annotation.type) {
            case 'box':
                ctx.beginPath();
                ctx.rect(
                    scaledPoints[0].x,
                    scaledPoints[0].y,
                    scaledPoints[1].x - scaledPoints[0].x,
                    scaledPoints[1].y - scaledPoints[0].y
                );
                if (forMask) {
                    ctx.fill();
                }
                break;
                
            case 'polygon':
                ctx.beginPath();
                ctx.moveTo(scaledPoints[0].x, scaledPoints[0].y);
                
                for (let i = 1; i < scaledPoints.length; i++) {
                    ctx.lineTo(scaledPoints[i].x, scaledPoints[i].y);
                }
                
                if (annotation.closed) {
                    ctx.closePath();
                }
                
                if (forMask) {
                    ctx.fill();
                }
                break;
                
            case 'freehand':
                ctx.beginPath();
                ctx.moveTo(scaledPoints[0].x, scaledPoints[0].y);
                
                for (let i = 1; i < scaledPoints.length; i++) {
                    ctx.lineTo(scaledPoints[i].x, scaledPoints[i].y);
                }
                
                if (forMask) {
                    ctx.lineWidth = 10; // Thicker line for mask
                    ctx.stroke();
                }
                break;
        }
    }
    
    // Function to reset annotation opacity
    function resetAnnotationOpacity() {
        // Hide tooltip
        const tooltip = document.getElementById('annotation-tooltip');
        if (tooltip) {
            tooltip.style.display = 'none';
        }
        
        // Redraw annotations normally
        drawAnnotations();
    }
    
    // Function to reset image position
    function resetImagePosition() {
        console.log("Resetting image position...");
        
        if (!annotationImage || !imageContainer) {
            console.error("Image element or container not found!");
            return;
        }
        
        // Set initial zoom level to 1 before calculating the proper fit
        zoomLevel = 1;
        
        // Call calculateAndCenterImage directly, which will handle everything
        if (annotationImage.complete && annotationImage.naturalWidth > 0) {
            calculateAndCenterImage();
        } else {
            // Set onload handler if image is not yet loaded
            annotationImage.onload = calculateAndCenterImage;
        }
    }
    
    // New function to calculate proper centering based on actual dimensions
    function calculateAndCenterImage() {
        // Get container dimensions
        const containerWidth = imageContainer.clientWidth;
        const containerHeight = imageContainer.clientHeight;
        
        // Set fixed dimensions for the image
        const fixedWidth = 800;
        const fixedHeight = 600;
        
        // Calculate scaling to fit the fixed size image in container
        const scaleX = containerWidth / fixedWidth;
        const scaleY = containerHeight / fixedHeight;
        
        // Use the smaller scale to ensure the whole image fits
        const fitScale = Math.min(scaleX, scaleY) * 0.9; // 90% of container to leave some margin
        
        // Set zoom level to fit scale
        zoomLevel = fitScale;
        
        // Reset pan values to center the image
        panX = 0;
        panY = 0;
        
        console.log("Centering image with zoom:", zoomLevel);
        
        // Apply transform to center the image
        annotationImage.style.position = 'absolute';
        annotationImage.style.left = '50%';
        annotationImage.style.top = '50%';
        annotationImage.style.transform = `translate(-50%, -50%) scale(${zoomLevel})`;
        
        // Make sure canvas is properly sized and positioned to match the image
        if (annotationCanvas) {
            annotationCanvas.width = containerWidth;
            annotationCanvas.height = containerHeight;
            
            // Match the canvas position to the container
            annotationCanvas.style.position = 'absolute';
            annotationCanvas.style.left = '0';
            annotationCanvas.style.top = '0';
        }
        
        // Update zoom level display
        if (zoomLevelDisplay) {
            zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
        }
        
        // Redraw annotations
        drawAnnotations();
    }
    
    // Function to update image position with current zoom and pan values
    function updateImagePosition() {
        if (!annotationImage) {
            console.error("Image element not found in updateImagePosition!");
            return;
        }
        
        // Apply transform using the centered approach with panning
        annotationImage.style.transform = `translate(calc(-50% + ${panX}px), calc(-50% + ${panY}px)) scale(${zoomLevel})`;
        
        // Update zoom level display
        if (zoomLevelDisplay) {
            zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
        }
        
        // Redraw annotations
        drawAnnotations();
    }
    
    // Function to calculate image position
    function calculateImagePosition() {
        if (!annotationImage || !imageContainer) return;
        
        const containerWidth = imageContainer.clientWidth;
        const containerHeight = imageContainer.clientHeight;
        const imgWidth = annotationImage.naturalWidth * zoomLevel;
        const imgHeight = annotationImage.naturalHeight * zoomLevel;
        
        console.log("Image natural dimensions:", annotationImage.naturalWidth, "x", annotationImage.naturalHeight);
        console.log("Scaled dimensions:", imgWidth, "x", imgHeight);
    }
    
    // Initialize canvas when modal is shown
    function initCanvas() {
        console.log("Initializing canvas...");
        if (!annotationCanvas) {
            console.error("Canvas element not found!");
            return;
        }
        if (!annotationImage) {
            console.error("Image element not found!");
            return;
        }
        if (!imageContainer) {
            console.error("Image container not found!");
            return;
        }
        
        // Get the container dimensions
        const containerWidth = imageContainer.clientWidth;
        const containerHeight = imageContainer.clientHeight;
        console.log("Container dimensions:", containerWidth, "x", containerHeight);
        
        // Set canvas dimensions
        annotationCanvas.width = containerWidth;
        annotationCanvas.height = containerHeight;
        console.log("Canvas dimensions set to:", containerWidth, "x", containerHeight);
        
        try {
            ctx = annotationCanvas.getContext('2d');
            console.log("Canvas context created successfully");
        } catch (e) {
            console.error("Failed to get canvas context:", e);
            return;
        }
        
        // Set up cursors first
        try {
            setupCursors();
            console.log("Cursors setup complete");
        } catch (e) {
            console.error("Error setting up cursors:", e);
        }
        
        // Ensure image is properly loaded before positioning
        console.log("Image complete status:", annotationImage.complete);
        console.log("Image natural dimensions:", 
            annotationImage.complete ? annotationImage.naturalWidth + "x" + annotationImage.naturalHeight : "not available");
            
        // Use a more robust method to ensure image is positioned correctly
        if (annotationImage.complete && annotationImage.naturalWidth > 0) {
            console.log("Image already loaded, centering directly");
            setTimeout(resetImagePosition, 50); // Small delay to ensure DOM is updated
        } else {
            console.log("Image not loaded yet, setting onload handler");
            annotationImage.onload = function() {
                console.log("Image loaded with dimensions:", 
                    annotationImage.naturalWidth + "x" + annotationImage.naturalHeight);
                setTimeout(resetImagePosition, 50); // Small delay after load
            };
        }
        
        console.log("Canvas initialization complete");
    }
    
    function centerImage() {
        if (annotationImage.complete && annotationImage.naturalWidth > 0) {
            calculateAndCenterImage();
        } else {
            annotationImage.onload = calculateAndCenterImage;
        }
    }
    
    // Replace the centerAtSpecificPoint function with a proper centering function
    function centerAtSpecificPoint() {
        // Use a short timeout to ensure the image dimensions are available
        setTimeout(() => {
            // Just use the standard centerImage function instead of trying to center at coordinates
            centerImage();
        }, 100);
    }
    
    // Modify the centerAtCoordinate function to be more robust
    function centerAtCoordinate(x, y) {
        // Make sure the canvas and image are initialized
        if (!annotationImage || !imageContainer) {
            console.error("Cannot center: image or container not ready");
            return;
        }
        
        // Get the natural dimensions of the image
        const imgNaturalWidth = annotationImage.naturalWidth;
        const imgNaturalHeight = annotationImage.naturalHeight;
        
        console.log(`Image natural dimensions: ${imgNaturalWidth} x ${imgNaturalHeight}`);
        
        if (imgNaturalWidth === 0 || imgNaturalHeight === 0) {
            console.error("Image dimensions not available yet");
            // Fall back to standard centering
            centerImage();
            return;
        }
        
        // Get container dimensions
        const containerWidth = imageContainer.clientWidth;
        const containerHeight = imageContainer.clientHeight;
        
        // Ensure coordinates are within image bounds
        const boundedX = Math.max(0, Math.min(x, imgNaturalWidth));
        const boundedY = Math.max(0, Math.min(y, imgNaturalHeight));
        
        // Calculate scale to fit the image properly
        const scaleX = containerWidth / imgNaturalWidth;
        const scaleY = containerHeight / imgNaturalHeight;
        const fitScale = Math.min(scaleX, scaleY);
        
        // Don't modify zoom level here, just use current zoom
        
        // Calculate the pan values needed to center the specified point
        panX = (containerWidth / 2) - (boundedX * zoomLevel);
        panY = (containerHeight / 2) - (boundedY * zoomLevel);
        
        console.log("Centering at:", {
            targetX: boundedX,
            targetY: boundedY,
            imageSize: `${imgNaturalWidth}x${imgNaturalHeight}`,
            containerSize: `${containerWidth}x${containerHeight}`,
            zoomLevel: zoomLevel,
            fitScale: fitScale,
            calculatedPan: `panX=${panX}, panY=${panY}`
        });
        
        // Update position
        annotationImage.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
        
        // Update zoom level display
        if (zoomLevelDisplay) {
            zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
        }
        
        // Redraw annotations
        drawAnnotations();
    }
    
    // Handle window resize
    window.addEventListener('resize', function() {
        if (annotationModal && annotationModal.style.display === 'flex') {
            // Recalculate canvas dimensions
            const containerWidth = imageContainer.clientWidth;
            const containerHeight = imageContainer.clientHeight;
            
            if (annotationCanvas) {
                annotationCanvas.width = containerWidth;
                annotationCanvas.height = containerHeight;
                // Recenter image on resize
                calculateAndCenterImage();
            }
        }
    });
    
    // Handle image panning
    function setupImagePanning() {
        let isPanning = false;
        let lastX, lastY;
        
        imageContainer.addEventListener('mousedown', function(e) {
            if (currentTool === 'hand' || (currentTool === 'select' && e.button === 1)) {
                isPanning = true;
                lastX = e.clientX;
                lastY = e.clientY;
                imageContainer.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });
        
        document.addEventListener('mousemove', function(e) {
            if (isPanning) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                
                panX += deltaX;
                panY += deltaY;
                
                lastX = e.clientX;
                lastY = e.clientY;
                
                updateImagePosition();
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isPanning) {
                isPanning = false;
                imageContainer.style.cursor = currentTool === 'hand' ? 'grab' : 'default';
            }
        });
        
        // Handle zooming with mouse wheel
        imageContainer.addEventListener('wheel', function(e) {
            e.preventDefault();
            
            const rect = imageContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate center of container
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            // Calculate position relative to center
            const relX = mouseX - centerX;
            const relY = mouseY - centerY;
            
            // Adjust zoom level with wheel delta
            const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoomLevel = Math.min(Math.max(0.1, zoomLevel * zoomDelta), 10);
            
            // Adjust pan to zoom toward mouse position
            const zoomRatio = newZoomLevel / zoomLevel;
            const newPanX = panX + (relX - relX * zoomRatio);
            const newPanY = panY + (relY - relY * zoomRatio);
            
            // Update zoom and pan values
            zoomLevel = newZoomLevel;
            panX = newPanX;
            panY = newPanY;
            
            // Update the image position
            updateImagePosition();
        });
    }
    
    // Draw annotations on canvas
    function drawAnnotations() {
        if (!ctx) return;
        
        ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        
        // Draw grid if enabled
        if (showGrid) {
            drawGrid();
        }
        
        // Draw all saved annotations
        annotations.forEach(annotation => {
            drawAnnotation(annotation, annotation === selectedAnnotation);
        });
        
        // Draw current annotation being created
        if (isDrawing && currentAnnotation) {
            drawAnnotation(currentAnnotation, true);
        }
    }
    

    
    function drawAnnotation(annotation, isSelected, isCommon = false) {
        if (!annotation) return;
        
        // Get class color from class list
        let classColor = '#6c5ce7'; // Default purple
        if (annotation.classId) {
            const classItem = document.querySelector(`.class-item[data-class-id="${annotation.classId}"]`);
            if (classItem) {
                const colorDiv = classItem.querySelector('.class-color');
                if (colorDiv) {
                    classColor = window.getComputedStyle(colorDiv).backgroundColor;
                }
            }
        }
        
        // Convert RGB to hex if needed
        if (classColor.startsWith('rgb')) {
            const rgb = classColor.match(/\d+/g);
            if (rgb && rgb.length >= 3) {
                classColor = '#' + 
                    parseInt(rgb[0]).toString(16).padStart(2, '0') +
                    parseInt(rgb[1]).toString(16).padStart(2, '0') +
                    parseInt(rgb[2]).toString(16).padStart(2, '0');
            }
        }
        
        // Adjust style based on selection state
        let fillOpacity = '44'; // Default opacity
        let strokeColor = isSelected ? colors.selection : classColor;
        
        ctx.strokeStyle = strokeColor;
        ctx.fillStyle = isSelected ? 
            `${colors.selection}${fillOpacity}` : 
            `${classColor}${fillOpacity}`;
        
        ctx.lineWidth = isSelected ? 3 : 2;
        
        const scaledPoints = annotation.points.map(point => ({
            x: point.x * zoomLevel + panX,
            y: point.y * zoomLevel + panY
        }));
        
        switch(annotation.type) {
            case 'box':
                ctx.beginPath();
                ctx.rect(
                    scaledPoints[0].x,
                    scaledPoints[0].y,
                    scaledPoints[1].x - scaledPoints[0].x,
                    scaledPoints[1].y - scaledPoints[0].y
                );
                ctx.fill();
                ctx.stroke();
                
                // Draw handles if selected
                if (isSelected) {
                    drawBoxHandles(scaledPoints);
                }
                break;
                
            case 'polygon':
                ctx.beginPath();
                ctx.moveTo(scaledPoints[0].x, scaledPoints[0].y);
                
                for (let i = 1; i < scaledPoints.length; i++) {
                    ctx.lineTo(scaledPoints[i].x, scaledPoints[i].y);
                }
                
                if (annotation.closed) {
                    ctx.closePath();
                }
                
                ctx.fill();
                ctx.stroke();
                
                // Draw vertices if selected
                if (isSelected) {
                    drawPolygonVertices(scaledPoints);
                }
                break;
                
            case 'freehand':
                ctx.beginPath();
                ctx.moveTo(scaledPoints[0].x, scaledPoints[0].y);
                
                for (let i = 1; i < scaledPoints.length; i++) {
                    ctx.lineTo(scaledPoints[i].x, scaledPoints[i].y);
                }
                
                ctx.stroke();
                break;
        }
    }
    
    function drawBoxHandles(points) {
        const handleSize = 8;
        ctx.fillStyle = colors.selection;
        
        // Draw corner handles
        const corners = [
            { x: points[0].x, y: points[0].y },
            { x: points[1].x, y: points[0].y },
            { x: points[1].x, y: points[1].y },
            { x: points[0].x, y: points[1].y }
        ];
        
        corners.forEach(corner => {
            ctx.beginPath();
            ctx.rect(
                corner.x - handleSize/2,
                corner.y - handleSize/2,
                handleSize,
                handleSize
            );
            ctx.fill();
        });
    }
    
    function drawPolygonVertices(points) {
        const handleSize = 8;
        ctx.fillStyle = colors.selection;
        
        points.forEach(point => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, handleSize/2, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // Set up annotation tools
    function setupAnnotationTools() {
        console.log("Setting up annotation tools...");
        console.log("Found toolButtons:", toolButtons ? toolButtons.length : 0);
        
        // Tool selection
        toolButtons.forEach(btn => {
            console.log("Setting up tool button:", btn.dataset.tool);
            btn.addEventListener('click', function() {
                console.log("Tool button clicked:", this.dataset.tool);
                
                // Remove active class from all tools
                toolButtons.forEach(b => b.classList.remove('active'));
                
                // Add active class to selected tool
                this.classList.add('active');
                
                // Update current tool
                currentTool = this.dataset.tool;
                console.log("Current tool set to:", currentTool);
                
                // Update cursor
                if (currentTool === 'hand') {
                        imageContainer.style.cursor = 'grab';
                } else if (currentTool === 'box' || currentTool === 'polygon' || currentTool === 'freehand') {
                        imageContainer.style.cursor = 'crosshair';
                } else {
                    imageContainer.style.cursor = 'default';
                }
                
                // Show/hide tool options
                document.querySelectorAll('.tool-option').forEach(option => {
                    option.style.display = 'none';
                });
                
                const toolOptions = document.getElementById(`${currentTool}-options`);
                if (toolOptions) {
                    toolOptions.style.display = 'block';
                } else {
                    console.log(`No options found for tool: ${currentTool}`);
                }
            });
        });
        
        // Class selection
        classItems.forEach(item => {
            item.addEventListener('click', function(e) {
                // Don't select class if clicking on the remove button
                if (e.target.closest('.remove-class')) {
                    return;
                }
                
                // Remove selected class from all items
                classItems.forEach(i => i.classList.remove('selected'));
                
                // Add selected class to this item
                this.classList.add('selected');
                
                // Set current class
                currentClass = {
                    id: this.dataset.classId,
                    name: this.querySelector('.class-name').textContent,
                    color: this.querySelector('.class-color').style.backgroundColor
                };
            });
            
            // Setup remove class button
            const removeBtn = item.querySelector('.remove-class');
            if (removeBtn) {
                removeBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const classId = item.dataset.classId;
                    const className = item.querySelector('.class-name').textContent;
                    
                    // Confirm deletion
                    if (confirm(`Are you sure you want to remove class "${className}"?`)) {
                        // Check if class is used in any annotations
                        const usedInAnnotations = annotations.some(ann => ann.classId == classId);
                        
                        if (usedInAnnotations) {
                            alert(`Cannot remove class "${className}" because it is used in annotations. Remove those annotations first.`);
                            return;
                        }
                        
                        // Send request to remove class
                        removeClass(classId);
                    }
                });
            }
        });
        
        // Select first class by default
        if (classItems.length > 0) {
            classItems[0].click();
        }
        
        // Add Class button
        if (addClassBtn) {
            addClassBtn.addEventListener('click', showAddClassDialog);
        }
        
        // Canvas interactions for drawing
        annotationCanvas.addEventListener('mousedown', function(e) {
            if (e.button !== 0 || currentTool === 'hand') return;
            
            const rect = annotationCanvas.getBoundingClientRect();
            const startX = (e.clientX - rect.left - panX) / zoomLevel;
            const startY = (e.clientY - rect.top - panY) / zoomLevel;
            
            switch(currentTool) {
                case 'select':
                    // Check if clicked on an annotation
                    selectedAnnotation = null;
                    for (let i = annotations.length - 1; i >= 0; i--) {
                        if (isPointInAnnotation(
                            startX,
                            startY,
                            annotations[i]
                        )) {
                            selectedAnnotation = annotations[i];
                            break;
                        }
                    }
                    drawAnnotations();
                    updateAnnotationsList();
                    break;
                    
                case 'box':
                    isDrawing = true;
                    currentAnnotation = {
                        id: Date.now(),
                        type: 'box',
                        points: [
                            { x: startX, y: startY },
                            { x: startX, y: startY }
                        ],
                        class: currentClass ? currentClass.name : 'default',
                        classId: currentClass ? currentClass.id : null
                    };
                    break;
                    
                case 'polygon':
                    if (!currentAnnotation) {
                        isDrawing = true;
                        currentAnnotation = {
                            id: Date.now(),
                            type: 'polygon',
                            points: [{ x: startX, y: startY }],
                            closed: false,
                            class: currentClass ? currentClass.name : 'default',
                            classId: currentClass ? currentClass.id : null
                        };
                    } else {
                        // Adding a new point to an existing polygon
                        currentAnnotation.points.push({ x: startX, y: startY });
                        
                        // Check if near the starting point to close the polygon
                        const firstPoint = currentAnnotation.points[0];
                        const distance = Math.sqrt(
                            Math.pow(startX - firstPoint.x, 2) + 
                            Math.pow(startY - firstPoint.y, 2)
                        );
                        
                        if (currentAnnotation.points.length > 2 && distance < 10 / zoomLevel) {
                            currentAnnotation.closed = true;
                            finishAnnotation();
                        }
                    }
                    break;
                    
                case 'freehand':
                    isDrawing = true;
                    currentAnnotation = {
                        id: Date.now(),
                        type: 'freehand',
                        points: [{ x: startX, y: startY }],
                        class: currentClass ? currentClass.name : 'default',
                        classId: currentClass ? currentClass.id : null
                    };
                    break;
            }
            
            drawAnnotations();
        });
        
        annotationCanvas.addEventListener('mousemove', function(e) {
            const rect = annotationCanvas.getBoundingClientRect();
            const currentX = (e.clientX - rect.left - panX) / zoomLevel;
            const currentY = (e.clientY - rect.top - panY) / zoomLevel;
            
            if (!isDrawing || !currentAnnotation) return;
            
            switch(currentAnnotation.type) {
                case 'box':
                    currentAnnotation.points[1] = { x: currentX, y: currentY };
                    break;
                    
                case 'polygon':
                    // For polygon tool, we show where the next point would be
                    if (currentAnnotation.points.length > 0 && currentAnnotation.tempPoint) {
                        currentAnnotation.tempPoint = { x: currentX, y: currentY };
                    } else {
                        currentAnnotation.tempPoint = { x: currentX, y: currentY };
                    }
                    break;
                    
                case 'freehand':
                    currentAnnotation.points.push({ x: currentX, y: currentY });
                    break;
            }
            
            drawAnnotations();
        });
        
        annotationCanvas.addEventListener('mouseup', function(e) {
            if (e.button !== 0) return;
            
            if (!isDrawing || !currentAnnotation) return;
            
            switch(currentAnnotation.type) {
                case 'box':
                case 'freehand':
                    finishAnnotation();
                    break;
                    
                // For polygons, mouseup doesn't finish the annotation
                // We keep adding points until explicitly finished by double-click or closing the path
            }
        });
        
        // Double click to finish polygon
        annotationCanvas.addEventListener('dblclick', function() {
            if (isDrawing && currentAnnotation && currentAnnotation.type === 'polygon') {
                if (currentAnnotation.points.length >= 3) {
                currentAnnotation.closed = true;
                finishAnnotation();
                }
            }
        });
        
        // Escape key to cancel current drawing
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && isDrawing) {
                isDrawing = false;
                currentAnnotation = null;
                drawAnnotations();
            }
        });
    }
    
    function isPointInAnnotation(x, y, annotation) {
        switch(annotation.type) {
            case 'box':
                const minX = Math.min(annotation.points[0].x, annotation.points[1].x);
                const maxX = Math.max(annotation.points[0].x, annotation.points[1].x);
                const minY = Math.min(annotation.points[0].y, annotation.points[1].y);
                const maxY = Math.max(annotation.points[0].y, annotation.points[1].y);
                
                return x >= minX && x <= maxX && y >= minY && y <= maxY;
                
            case 'polygon':
                return isPointInPolygon(x, y, annotation.points);
                
            case 'freehand':
                // Use a simpler approach for freehand by checking distance to each line segment
                for (let i = 0; i < annotation.points.length - 1; i++) {
                    const dist = distanceToLineSegment(
                        annotation.points[i].x, annotation.points[i].y,
                        annotation.points[i+1].x, annotation.points[i+1].y,
                        x, y
                    );
                    if (dist < 5 / zoomLevel) return true;
                }
                return false;
        }
        return false;
    }
    
    function isPointInPolygon(x, y, points) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x, yi = points[i].y;
            const xj = points[j].x, yj = points[j].y;
            
            const intersect = ((yi > y) !== (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
    
    function distanceToLineSegment(x1, y1, x2, y2, x, y) {
        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        
        if (len_sq !== 0) param = dot / len_sq;
        
        let xx, yy;
        
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }
        
        const dx = x - xx;
        const dy = y - yy;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    function drawGrid() {
        const gridSize = 50 * zoomLevel;
        ctx.strokeStyle = colors.grid;
        ctx.lineWidth = 1;
        
        // Draw vertical lines
        for (let x = panX % gridSize; x < annotationCanvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, annotationCanvas.height);
            ctx.stroke();
        }
        
        // Draw horizontal lines
        for (let y = panY % gridSize; y < annotationCanvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(annotationCanvas.width, y);
            ctx.stroke();
        }
    }
    
    function finishAnnotation() {
        if (!currentAnnotation) return;
        
        // Normalize box coordinates
        if (currentAnnotation.type === 'box') {
            const points = currentAnnotation.points;
            currentAnnotation.points = [
                {
                    x: Math.min(points[0].x, points[1].x),
                    y: Math.min(points[0].y, points[1].y)
                },
                {
                    x: Math.max(points[0].x, points[1].x),
                    y: Math.max(points[0].y, points[1].y)
                }
            ];
        }
        
        // Remove temporary point used for polygon preview
        if (currentAnnotation.tempPoint) {
            delete currentAnnotation.tempPoint;
        }
        
        // Add to annotations list
        annotations.push(currentAnnotation);
        
        saveToHistory();
        
        // Reset drawing state
        isDrawing = false;
        
        // Keep currentAnnotation for polygon until explicitly finished
        if (currentAnnotation.type !== 'polygon' || currentAnnotation.closed) {
            currentAnnotation = null;
        }
        
        // Update UI
        drawAnnotations();
        
        updateAnnotationsList();
    }
    
    function loadAnnotations(imageId) {
        fetch(`/api/images/${imageId}/annotations`)
            .then(response => response.json())
            .then(data => {
                if (data.annotations) {
                    // Convert API annotations to our format
                    annotations = data.annotations.map(ann => {
                        const newAnn = {
                            id: ann.id,
                            class: ann.class_name,
                            classId: ann.class_id,
                            type: ann.type
                        };
                        
                        if (ann.type === 'box') {
                            newAnn.points = [
                                { x: ann.x_min, y: ann.y_min },
                                { x: ann.x_max, y: ann.y_max }
                            ];
                        } else if (ann.type === 'polygon') {
                            newAnn.points = ann.points;
                            newAnn.closed = true;
                        }
                        
                        return newAnn;
                    });
                    
                        drawAnnotations();
                    updateAnnotationsList();
                    
                    // Update the annotation status badge on the card
                    const currentCard = document.querySelector(`.image-card[data-image-id="${imageId}"]`);
                    if (currentCard) {
                        const statusBadge = currentCard.querySelector('.status-badge');
                        if (statusBadge && annotations.length > 0) {
                            statusBadge.className = 'status-badge annotated';
                            statusBadge.innerHTML = '<i class="fas fa-check-circle"></i> Annotated';
                            
                            // Update annotation count display
                            const metaDiv = currentCard.querySelector('.image-meta div');
                            let annotationCount = currentCard.querySelector('.annotation-count');
                            
                            if (!annotationCount && metaDiv) {
                                annotationCount = document.createElement('span');
                                annotationCount.className = 'annotation-count';
                                metaDiv.appendChild(annotationCount);
                            }
                            
                            if (annotationCount) {
                                annotationCount.innerHTML = `<i class="fas fa-tag"></i> ${annotations.length}`;
                            }
                            
                            // Update progress bar in card
                            const progressFill = currentCard.querySelector('.progress-fill');
                            if (progressFill) {
                                progressFill.style.width = '100%';
                            }
                        } else if (statusBadge && annotations.length === 0) {
                            statusBadge.className = 'status-badge not-annotated';
                            statusBadge.innerHTML = '<i class="fas fa-clock"></i> Not Annotated';
                            
                            // Remove annotation count if it exists
                            const annotationCount = currentCard.querySelector('.annotation-count');
                            if (annotationCount) {
                                annotationCount.remove();
                            }
                            
                            // Update progress bar
                            const progressFill = currentCard.querySelector('.progress-fill');
                            if (progressFill) {
                                progressFill.style.width = '0%';
                            }
                        }
                    }
                    
                    // Update metrics
                    updateAnnotationMetrics();
                }
            })
            .catch(error => {
                console.error('Error loading annotations:', error);
            });
    }
    
    // Set up control buttons
    function setupControlButtons() {
        // Undo/Redo
        if (undoBtn) {
            undoBtn.addEventListener('click', () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    annotations = JSON.parse(JSON.stringify(history[historyIndex]));
                    drawAnnotations();
                    updateAnnotationsList();
                    updateHistoryButtons();
                }
            });
        }
        
        if (redoBtn) {
            redoBtn.addEventListener('click', () => {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    annotations = JSON.parse(JSON.stringify(history[historyIndex]));
                    drawAnnotations();
                    updateAnnotationsList();
                    updateHistoryButtons();
                }
            });
        }
        
        // Zoom controls
        if (zoomInBtn) {
            zoomInBtn.addEventListener('click', () => {
                zoomLevel *= 1.2;
                zoomLevel = Math.min(Math.max(0.1, zoomLevel), 10);
                updateImagePosition();
                zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            });
        }
        
        if (zoomOutBtn) {
            zoomOutBtn.addEventListener('click', () => {
                zoomLevel *= 0.8;
                zoomLevel = Math.min(Math.max(0.1, zoomLevel), 10);
                updateImagePosition();
                zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            });
        }
        
        if (fitScreenBtn) {
            fitScreenBtn.addEventListener('click', resetImagePosition);
        }
        
        if (resetViewBtn) {
            resetViewBtn.addEventListener('click', resetImagePosition);
        }
        
        // Add event listener for the center-at-point button
        const centerAtPointBtn = document.getElementById('center-at-point');
        if (centerAtPointBtn) {
            centerAtPointBtn.addEventListener('click', () => {
                centerAtSpecificPoint();
            });
        }
        
        if (toggleGridBtn) {
            toggleGridBtn.addEventListener('click', () => {
                showGrid = !showGrid;
                drawAllAnnotations();
                toggleGridBtn.classList.toggle('active', showGrid);
            });
        }
        
        // Clear all annotations
        if (clearAllBtn) {
            clearAllBtn.addEventListener('click', () => {
                    if (confirm('Are you sure you want to delete all annotations for this image?')) {
                    annotations = [];
                    selectedAnnotation = null;
                    saveToHistory();
                    drawAnnotations();
                    updateAnnotationsList();
                }
            });
        }
        
        // Save annotations
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                saveAnnotations();
            });
        }
        
        // Export annotations
        if (exportAnnotationsBtn) {
            exportAnnotationsBtn.addEventListener('click', () => {
                const allAnnotations = {
                    imageSpecific: annotations,
                    common: commonAnnotations
                };
                
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(allAnnotations));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "annotations.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            });
        }
    }
    
    function saveAnnotations() {
        // Return early if no annotations to save
        if (annotations.length === 0) {
            console.log('No annotations to save');
            return Promise.resolve();
        }
        
        console.log('Saving annotations:', annotations);
        
        return new Promise((resolve, reject) => {
            // Convert annotations to the format expected by the API
            const annotationsToSave = annotations.map(ann => {
                const apiAnn = {
                    type: ann.type,
                    class_id: ann.classId
                };
                
                if (ann.type === 'box' && ann.points.length === 2) {
                    apiAnn.x_min = ann.points[0].x;
                    apiAnn.y_min = ann.points[0].y;
                    apiAnn.x_max = ann.points[1].x;
                    apiAnn.y_max = ann.points[1].y;
                } else if (ann.type === 'polygon') {
                    apiAnn.points = ann.points;
                }
                
                return apiAnn;
            });
            
            // Send to backend
            fetch(`/api/images/${currentImageId}/annotations/batch`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                    annotations: annotationsToSave
            }),
        })
        .then(response => response.json())
        .then(data => {
            console.log('Success:', data);
                
                // Update local annotations with server IDs
                if (data.annotations) {
                    annotations = data.annotations.map(ann => {
                        const newAnn = {
                            id: ann.id,
                            class: ann.class_name,
                            classId: ann.class_id,
                            type: ann.type
                        };
                        
                        if (ann.type === 'box') {
                            newAnn.points = [
                                { x: ann.x_min, y: ann.y_min },
                                { x: ann.x_max, y: ann.y_max }
                            ];
                        } else if (ann.type === 'polygon') {
                            newAnn.points = ann.points;
                            newAnn.closed = true;
                        }
                        
                        return newAnn;
                    });
                }
                
                resolve(data);
        })
            .catch(error => {
            console.error('Error:', error);
                reject(error);
            });
        });
    }
    
    // Set up save button
    if (saveBtn) {
        saveBtn.addEventListener('click', function() {
            console.log("Save button clicked");
            saveAnnotations().then(() => {
                // Show success message
                console.log("Annotations saved successfully!");
                alert('Annotations saved successfully!');
            }).catch(error => {
                console.error('Error saving annotations:', error);
                alert('Error saving annotations. Please try again.');
            });
        });
    }
    
    // Add Class dialog
    function showAddClassDialog() {
        // Create dialog elements
        const dialogOverlay = document.createElement('div');
        dialogOverlay.className = 'dialog-overlay';
        
        const dialog = document.createElement('div');
        dialog.className = 'add-class-dialog';
        dialog.innerHTML = `
            <h3>Add New Class</h3>
            <div class="dialog-field">
                <label for="class-name">Class Name</label>
                <input type="text" id="class-name" placeholder="Enter class name">
            </div>
            <div class="dialog-field">
                <label for="class-color">Class Color</label>
                <input type="color" id="class-color" value="#6c5ce7">
            </div>
            <div class="dialog-actions">
                <button class="dialog-btn dialog-btn-cancel">Cancel</button>
                <button class="dialog-btn dialog-btn-confirm">Add Class</button>
            </div>
        `;
        
        // Add dialog to DOM
        document.body.appendChild(dialogOverlay);
        document.body.appendChild(dialog);
        
        // Add event listeners
        const cancelBtn = dialog.querySelector('.dialog-btn-cancel');
        const confirmBtn = dialog.querySelector('.dialog-btn-confirm');
        const nameInput = dialog.querySelector('#class-name');
        const colorInput = dialog.querySelector('#class-color');
        
        cancelBtn.addEventListener('click', () => {
            dialogOverlay.remove();
            dialog.remove();
        });
        
        confirmBtn.addEventListener('click', () => {
            const name = nameInput.value.trim();
            const color = colorInput.value;
            
            if (name) {
                createNewClass(name, color);
                dialogOverlay.remove();
                dialog.remove();
            } else {
                alert('Please enter a class name');
            }
        });
    }
    
    function createNewClass(name, color) {
        // Send request to create new class
        fetch(`/api/projects/${document.querySelector('[data-project-id]').dataset.projectId}/classes`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: name,
                color: color
            }),
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                alert('Error creating class: ' + data.error);
            } else {
                // Add new class to the list
                const classList = document.querySelector('.class-list');
                
                // Add before the "Add Class" button
                const addClassBtn = document.querySelector('.add-class-btn');
                
                const newClassItem = document.createElement('div');
                newClassItem.className = 'class-item';
                newClassItem.dataset.classId = data.id;
                newClassItem.innerHTML = `
                    <div class="class-color" style="background-color: ${data.color}"></div>
                    <div class="class-name">${data.name}</div>
                `;
                
                // Add click event
                newClassItem.addEventListener('click', function() {
                    // Remove selected class from all items
                    document.querySelectorAll('.class-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    // Add selected class to this item
                    this.classList.add('selected');
                    
                    // Set current class
                    currentClass = {
                        id: this.dataset.classId,
                        name: this.querySelector('.class-name').textContent,
                        color: this.querySelector('.class-color').style.backgroundColor
                    };
                });
                
                classList.insertBefore(newClassItem, addClassBtn);
            }
        })
        .catch(error => {
            console.error('Error creating class:', error);
            alert('Error creating class. Please try again.');
        });
    }
    
    // Update annotations list
    function updateAnnotationsList() {
        const annotationsList = document.getElementById('annotations-list');
        if (!annotationsList) return;
        
        annotationsList.innerHTML = '';
        
        if (annotations.length === 0) {
            annotationsList.innerHTML = '<div class="no-annotations">No annotations yet</div>';
            return;
        }
        
        // Add annotations
        annotations.forEach(annotation => {
            const item = document.createElement('div');
            item.className = `annotation-item ${annotation === selectedAnnotation ? 'selected' : ''}`;
            item.dataset.id = annotation.id;
            
            const typeLabel = annotation.type.charAt(0).toUpperCase() + annotation.type.slice(1);
            
            // Get class color
            let classColor = '#6c5ce7'; // Default purple
            if (annotation.classId) {
                const classItem = document.querySelector(`.class-item[data-class-id="${annotation.classId}"]`);
                if (classItem) {
                    const colorDiv = classItem.querySelector('.class-color');
                    if (colorDiv) {
                        classColor = window.getComputedStyle(colorDiv).backgroundColor;
                    }
                }
            }
            
            item.innerHTML = `
                <div class="annotation-item-header">
                    <div class="annotation-label">
                        <div class="annotation-color" style="background-color: ${classColor}"></div>
                        <span>${typeLabel}</span>
                    </div>
                    <div class="annotation-actions">
                        <button class="annotation-btn edit-btn" title="Edit"><i class="fas fa-pen"></i></button>
                        <button class="annotation-btn delete-btn" title="Delete"><i class="fas fa-trash"></i></button>
                    </div>
                </div>
                <div class="annotation-details">
                    <div class="annotation-class">${annotation.class || 'No class'}</div>
                </div>
            `;
            
            // Add click event to select annotation
            item.addEventListener('click', (e) => {
                if (!e.target.closest('.annotation-btn')) {
                    selectedAnnotation = annotation;
                    updateAnnotationsList();
                    drawAnnotations();
                }
            });
            
            // Add edit button event
            const editBtn = item.querySelector('.edit-btn');
            if (editBtn) {
                editBtn.addEventListener('click', () => {
                    selectedAnnotation = annotation;
                    enterEditMode(annotation);
                    updateAnnotationsList();
                    drawAnnotations();
                });
            }
            
            // Add delete button event
            const deleteBtn = item.querySelector('.delete-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => {
                    const index = annotations.findIndex(a => a.id === annotation.id);
                    if (index !== -1) {
                        annotations.splice(index, 1);
                        if (selectedAnnotation === annotation) {
                            selectedAnnotation = null;
                        }
                        saveToHistory();
                        updateAnnotationsList();
                        drawAnnotations();
                    }
                });
            }
            
            annotationsList.appendChild(item);
        });
    }
    
    function enterEditMode(annotation) {
        // Set current tool based on annotation type
        const toolBtn = document.querySelector(`.tool-btn[data-tool="${annotation.type}"]`);
        if (toolBtn) {
            toolBtn.click();
        }
        
        // Select the class of this annotation
        const classItem = document.querySelector(`.class-item[data-class-id="${annotation.classId}"]`);
        if (classItem) {
            classItem.click();
        }
        
        // For future: implement specific edit behaviors based on annotation type
        // This could involve showing handles for resizing boxes, moving polygon points, etc.
    }
    
    function setImageSplit(imageId, split) {
        // Send request to update image split
        fetch(`/api/images/${imageId}/split`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ split: split })
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                alert('Error updating dataset split: ' + data.error);
            } else {
                // Update UI to reflect the new split
                const splitButtons = document.querySelectorAll('.split-btn');
                splitButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.split === split);
                });
                
                // Update status on the image card
                const imageCard = document.querySelector(`.image-card[data-image-id="${imageId}"]`);
                if (imageCard) {
                    const splitBadge = imageCard.querySelector('.split-badge') || document.createElement('div');
                    splitBadge.className = 'split-badge';
                    splitBadge.dataset.split = split;
                    splitBadge.textContent = split.charAt(0).toUpperCase() + split.slice(1);
                    
                    // Find the meta container and add/update the badge
                    const metaContainer = imageCard.querySelector('.image-meta div');
                    if (metaContainer && !imageCard.querySelector('.split-badge')) {
                        metaContainer.appendChild(splitBadge);
                    }
                }
            }
        })
        .catch(error => {
            console.error('Error updating split:', error);
            alert('Error updating dataset split. Please try again.');
        });
    }
    
    // History management for undo/redo
    function saveToHistory() {
        // If we're not at the end of the history, remove future states
        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }
        
        // Save a deep copy of the current annotations
        const annotationsCopy = JSON.parse(JSON.stringify(annotations));
        history.push(annotationsCopy);
        historyIndex = history.length - 1;
        
        // Update undo/redo button states
        updateHistoryButtons();
    }
    
    function updateHistoryButtons() {
        if (undoBtn) {
            undoBtn.disabled = historyIndex < 0;
            undoBtn.style.opacity = historyIndex < 0 ? 0.5 : 1;
        }
        
        if (redoBtn) {
            redoBtn.disabled = historyIndex >= history.length - 1;
            redoBtn.style.opacity = historyIndex >= history.length - 1 ? 0.5 : 1;
        }
    }
    
    function removeClass(classId) {
        // Send request to delete class
        fetch(`/api/projects/${document.querySelector('[data-project-id]').dataset.projectId}/classes/${classId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => {
            if (response.ok) {
                // Remove class from DOM
                const classItem = document.querySelector(`.class-item[data-class-id="${classId}"]`);
                if (classItem) {
                    classItem.remove();
                    
                    // Select another class if the removed one was selected
                    if (classItem.classList.contains('selected')) {
                        const firstRemainingClass = document.querySelector('.class-item');
                        if (firstRemainingClass) {
                            firstRemainingClass.click();
                        } else {
                            currentClass = null;
                        }
                    }
                }
            } else {
                alert('Error removing class. Please try again.');
            }
        })
        .catch(error => {
            console.error('Error removing class:', error);
            alert('Error removing class. Please try again.');
        });
    }
    
    // Open annotation modal when clicking an image or annotate button
    imageCards.forEach(card => {
        // Add click handler for annotate button
        const annotateBtn = card.querySelector('.annotate-btn');
        if (annotateBtn) {
            annotateBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                console.log("Annotate button clicked");
                
                // Show annotation modal
                imageCards.forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                
                // Make sure the modal is visible
                if (annotationModal) {
                annotationModal.style.display = 'flex';
                    console.log("Set modal to display flex");
                } else {
                    console.error("Annotation modal element not found");
                }
                
                // Get the image ID
                currentImageId = card.dataset.imageId;
                console.log("Current image ID:", currentImageId);
                
                // Update current image index
                updateCurrentImageIndex();
                
                // Initialize annotation canvas
                setTimeout(() => {
                    initCanvas();
                    setupImagePanning();
                    setupAnnotationTools();
                    setupControlButtons();
                    
                    // Load existing annotations
                    loadAnnotations(currentImageId);
                    
                    // Initialize empty history
                    history = [];
                    historyIndex = -1;
                    saveToHistory();
                    updateAnnotationsList();
                    
                    // Ensure consistent positioning on all images
                    centerAtSpecificPoint();
                }, 100);
            });
        }
        
        // Add click handler for delete button
        const deleteBtn = card.querySelector('.delete-btn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                if (confirm('Are you sure you want to remove this image?')) {
                    // Here you would handle image deletion
                }
            });
        }
        
        // Add click handler for the card itself (excluding buttons)
        card.addEventListener('click', function(e) {
            // Don't trigger if clicking on a button
            if (e.target.closest('.image-action-btn')) {
                return;
            }
            
            // Remove selected class from all cards
            imageCards.forEach(c => c.classList.remove('selected'));
            // Add selected class to clicked card
            card.classList.add('selected');
            // Show annotation modal
            annotationModal.style.display = 'flex';
            
            // Get the image ID
            currentImageId = card.dataset.imageId;
            
            // Update current image index
            updateCurrentImageIndex();
            
            // Initialize annotation canvas
            setTimeout(() => {
                initCanvas();
                setupImagePanning();
                setupAnnotationTools();
                setupControlButtons();
                
                // Load existing annotations
                loadAnnotations(currentImageId);
                
                // Initialize empty history
                history = [];
                historyIndex = -1;
                saveToHistory();
                updateAnnotationsList();
            }, 100);
        });
        

    });
    
    // Navigation between images functions already defined above
    
    // Setup next/previous navigation buttons
    if (prevImageBtn) {
    prevImageBtn.addEventListener('click', () => {
        if (currentImageIndex > 0) {
                navigateToImage(currentImageIndex - 1);
        }
    });
    }
    
    if (nextImageBtn) {
    nextImageBtn.addEventListener('click', () => {
        if (currentImageIndex < imageCards.length - 1) {
                navigateToImage(currentImageIndex + 1);
        }
    });
    }
    
    function navigateToImage(index) {
        // Save current annotations before navigating
        saveAnnotations().then(() => {
            // Update current index
            currentImageIndex = index;
            
            // Get the new image card
            const newCard = imageCards[index];
            if (!newCard) return;
            
            // Update selected card
            imageCards.forEach(c => c.classList.remove('selected'));
            newCard.classList.add('selected');
            
            // Update current image ID
            currentImageId = newCard.dataset.imageId;
            
            // Update UI
            const currentImagePos = document.getElementById('current-image-pos');
            if (currentImagePos) {
                currentImagePos.textContent = index + 1;
            }
            
            // Update image source
            const imgSrc = newCard.querySelector('img').getAttribute('src');
            console.log("Loading new image:", imgSrc);
            
            // Reset canvas and annotations
            annotations = [];
            selectedAnnotation = null;
            history = [];
            historyIndex = -1;
            
            // Clear any existing onload handler
            annotationImage.onload = null;
            
            // Set new onload handler
            annotationImage.onload = function() {
                console.log("New image loaded:", 
                    annotationImage.naturalWidth + "x" + annotationImage.naturalHeight);
                // Reset view and load annotations
                setTimeout(() => {
                    initCanvas();
                    loadAnnotations(currentImageId);
                    saveToHistory();
                    updateAnnotationsList();
                }, 50);
            };
            
            // Set the image source after setting up onload
            annotationImage.src = imgSrc;
            
            // If the image is already cached and loads immediately
            if (annotationImage.complete) {
                console.log("Image loaded from cache");
                setTimeout(() => {
                    initCanvas();
                    loadAnnotations(currentImageId);
                    saveToHistory();
                    updateAnnotationsList();
                }, 50);
            }
        }).catch(error => {
            alert('Error saving annotations before navigation. Please try again.');
        });
    }
    
    // Function to prompt for dataset split after annotation
    function promptForDatasetSplit() {
        console.log("Prompting for dataset split...");
        // Check if the image already has a split
        return new Promise((resolve) => {
            fetch(`/api/images/${currentImageId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.image) {
                        const currentSplit = data.image.split;
                        
                        // Only prompt if no split is set
                        if (!currentSplit) {
                            // Create custom modal for dataset split
                            const modal = document.createElement('div');
                            modal.className = 'dataset-split-modal';
                            modal.innerHTML = `
                                <div class="dataset-split-modal-content">
                                    <h3>Select Dataset Split</h3>
                                    <p>Where would you like to use this image?</p>
                                    <div class="split-buttons">
                                        <button class="split-btn train-btn" data-split="train">Training (80%)</button>
                                        <button class="split-btn val-btn" data-split="val">Validation (10%)</button>
                                        <button class="split-btn test-btn" data-split="test">Testing (10%)</button>
                                    </div>
                                    <div class="split-actions">
                                        <button class="btn dialog-btn-cancel">Skip</button>
                                        <button class="btn dialog-btn-close">Close Editor</button>
                                    </div>
                                </div>
                            `;
                            
                            document.body.appendChild(modal);
                            
                            // Add event listeners to buttons
                            const splitButtons = modal.querySelectorAll('.split-btn');
                            splitButtons.forEach(btn => {
                                btn.addEventListener('click', function() {
                                    const split = this.dataset.split;
                                    setImageSplit(currentImageId, split).then(() => {
                                        modal.remove();
                                        resolve(); // Resolve the promise
                                    });
                                });
                            });
                            
                            // Skip button
                            const skipBtn = modal.querySelector('.dialog-btn-cancel');
                            skipBtn.addEventListener('click', () => {
                                modal.remove();
                                resolve(); // Resolve the promise
                            });
                            
                            // Close button
                            const closeBtn = modal.querySelector('.dialog-btn-close');
                            closeBtn.addEventListener('click', () => {
                                modal.remove();
                                annotationModal.style.display = 'none';
                                resolve(); // Resolve the promise
                            });
                        } else {
                            // If split already set, immediately resolve
                            resolve();
                        }
                    } else {
                        resolve();
                    }
                })
                .catch(error => {
                    console.error('Error checking image split:', error);
                    resolve(); // Resolve on error
                });
        });
    }
    
    // Close annotation modal
    if (closeAnnotationBtn) {
        closeAnnotationBtn.addEventListener('click', function() {
            console.log("Close button clicked");
            
            // Save annotations before closing
            saveAnnotations()
                .then(() => {
                    console.log("Annotations saved successfully");
                    // Check if we should prompt for dataset split
                    return promptForDatasetSplit();
                })
                .then(() => {
                    console.log("Dataset split handling complete");
                    // Close the modal if it hasn't been closed by dataset split dialog
                    if (annotationModal.style.display !== 'none') {
                annotationModal.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error in close process:', error);
                // Close anyway
                annotationModal.style.display = 'none';
            });
        });
    }
    
    // Function to update annotation counts in the UI
    function updateAnnotationMetrics() {
        console.log("Updating annotation metrics");
        // Count annotated images
        let annotatedCount = 0;
        imageCards.forEach(card => {
            const hasAnnotations = card.querySelector('.status-badge.annotated') !== null;
            if (hasAnnotations) {
                annotatedCount++;
            }
        });
        
        const totalImages = imageCards.length;
        const notAnnotatedCount = totalImages - annotatedCount;
        
        // Update metrics display
        const metricBoxes = document.querySelectorAll('.metric-box .metric-value');
        if (metricBoxes.length >= 3) {
            metricBoxes[0].textContent = totalImages; // Total Images
            metricBoxes[1].textContent = annotatedCount; // Annotated
            metricBoxes[2].textContent = notAnnotatedCount; // Not Annotated
        }
        
        // Update progress bar
        const progressFill = document.querySelector('.progress-bar .progress-fill');
        const progressPercentage = document.querySelector('.progress-percentage');
        
        if (progressFill && progressPercentage) {
            const percentage = totalImages > 0 ? Math.round((annotatedCount / totalImages) * 100) : 0;
            progressFill.style.width = `${percentage}%`;
            progressPercentage.textContent = `${percentage}% Complete`;
        }
    }
    
    // Call updateAnnotationMetrics when page loads
    updateAnnotationMetrics();
    
    // Update the saveAnnotations function to refresh UI after saving
    const originalSaveAnnotations = saveAnnotations;
    saveAnnotations = function() {
        return originalSaveAnnotations().then(result => {
            // Update the image card status badge
            const currentCard = document.querySelector(`.image-card[data-image-id="${currentImageId}"]`);
            if (currentCard && annotations.length > 0) {
                const statusBadge = currentCard.querySelector('.status-badge');
                if (statusBadge) {
                    statusBadge.className = 'status-badge annotated';
                    statusBadge.innerHTML = '<i class="fas fa-check-circle"></i> Annotated';
                    
                    // Update annotation count display
                    const metaDiv = currentCard.querySelector('.image-meta div');
                    let annotationCount = currentCard.querySelector('.annotation-count');
                    
                    if (!annotationCount && metaDiv) {
                        annotationCount = document.createElement('span');
                        annotationCount.className = 'annotation-count';
                        metaDiv.appendChild(annotationCount);
                    }
                    
                    if (annotationCount) {
                        annotationCount.innerHTML = `<i class="fas fa-tag"></i> ${annotations.length}`;
                    }
                    
                    // Update progress bar in card
                    const progressFill = currentCard.querySelector('.progress-fill');
                    if (progressFill) {
                        progressFill.style.width = '100%';
                    }
                }
            } else if (currentCard && annotations.length === 0) {
                // If all annotations are removed
                const statusBadge = currentCard.querySelector('.status-badge');
                if (statusBadge) {
                    statusBadge.className = 'status-badge not-annotated';
                    statusBadge.innerHTML = '<i class="fas fa-clock"></i> Not Annotated';
                    
                    // Remove annotation count if it exists
                    const annotationCount = currentCard.querySelector('.annotation-count');
                    if (annotationCount) {
                        annotationCount.remove();
                    }
                    
                    // Update progress bar
                    const progressFill = currentCard.querySelector('.progress-fill');
                    if (progressFill) {
                        progressFill.style.width = '0%';
                    }
                }
            }
            
            // Update the metrics at the top of the page
            updateAnnotationMetrics();
            
            return result;
        });
    };
    
    // Setup filter and search functionality
    const imageSearchInput = document.getElementById('image-search');
    const statusFilter = document.getElementById('status-filter');
    const sortFilter = document.getElementById('sort-filter');
    const applyFilterBtn = document.getElementById('apply-filter-btn');

    // Apply filters and search
    function applyFiltersAndSearch() {
        const searchTerm = imageSearchInput.value.toLowerCase();
        const statusValue = statusFilter.value;
        const sortValue = sortFilter.value;
        
        console.log(`Applying filters: Status=${statusValue}, Sort=${sortValue}, Search="${searchTerm}"`);
        
        // Filter images based on status and search term
        imageCards.forEach(card => {
            let shouldShow = true;
            
            // Apply status filter
            if (statusValue !== 'all') {
                const isAnnotated = card.querySelector('.status-badge.annotated') !== null;
                if (statusValue === 'annotated' && !isAnnotated) {
                    shouldShow = false;
                }
                if (statusValue === 'unannotated' && isAnnotated) {
                    shouldShow = false;
                }
            }
            
            // Apply search filter
            if (searchTerm && shouldShow) {
                const filename = card.querySelector('.image-filename').textContent.toLowerCase();
                if (!filename.includes(searchTerm)) {
                    shouldShow = false;
                }
            }
            
            // Show or hide the card
            card.style.display = shouldShow ? '' : 'none';
        });
        
        // Sort images
        const imageGrid = document.querySelector('.image-grid');
        const cardsArray = Array.from(imageCards);
        
        if (sortValue === 'recent') {
            cardsArray.sort((a, b) => {
                const dateA = a.querySelector('.image-date')?.textContent || '';
                const dateB = b.querySelector('.image-date')?.textContent || '';
                return dateB.localeCompare(dateA);
            });
        } else if (sortValue === 'oldest') {
            cardsArray.sort((a, b) => {
                const dateA = a.querySelector('.image-date')?.textContent || '';
                const dateB = b.querySelector('.image-date')?.textContent || '';
                return dateA.localeCompare(dateB);
            });
        } else if (sortValue === 'name') {
            cardsArray.sort((a, b) => {
                const nameA = a.querySelector('.image-filename')?.textContent.toLowerCase() || '';
                const nameB = b.querySelector('.image-filename')?.textContent.toLowerCase() || '';
                return nameA.localeCompare(nameB);
            });
        }
        
        // Reorder cards in the DOM
        cardsArray.forEach(card => {
            imageGrid.appendChild(card);
        });
        
        // Update metrics based on visible cards
        updateFilteredMetrics();
    }
    
    // Update metrics based on filtered/visible cards
    function updateFilteredMetrics() {
        let visibleCount = 0;
        let annotatedCount = 0;
        
        imageCards.forEach(card => {
            if (card.style.display !== 'none') {
                visibleCount++;
                if (card.querySelector('.status-badge.annotated')) {
                    annotatedCount++;
                }
            }
        });
        
        const notAnnotatedCount = visibleCount - annotatedCount;
        
        // Update metrics display for filtered view
        const metricBoxes = document.querySelectorAll('.metric-box .metric-value');
        if (metricBoxes.length >= 3) {
            metricBoxes[0].textContent = visibleCount; // Total Images
            metricBoxes[1].textContent = annotatedCount; // Annotated
            metricBoxes[2].textContent = notAnnotatedCount; // Not Annotated
        }
        
        // Update progress bar
        const progressFill = document.querySelector('.progress-bar .progress-fill');
        const progressPercentage = document.querySelector('.progress-percentage');
        
        if (progressFill && progressPercentage) {
            const percentage = visibleCount > 0 ? Math.round((annotatedCount / visibleCount) * 100) : 0;
            progressFill.style.width = `${percentage}%`;
            progressPercentage.textContent = `${percentage}% Complete`;
        }
    }
    
    // Add event listeners for search and filter controls
    if (applyFilterBtn) {
        applyFilterBtn.addEventListener('click', applyFiltersAndSearch);
    }
    
    if (imageSearchInput) {
        imageSearchInput.addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                applyFiltersAndSearch();
            }
        });
    }
    
    // Apply filters on status and sort change
    if (statusFilter) {
        statusFilter.addEventListener('change', applyFiltersAndSearch);
    }
    
    if (sortFilter) {
        sortFilter.addEventListener('change', applyFiltersAndSearch);
    }
    
    // Handle "Add to Dataset" button click
    const addToDatasetBtn = document.getElementById('add-to-dataset-btn');
    const datasetSplitModal = document.getElementById('dataset-split-modal');
    const closeDatasetModalBtn = document.getElementById('close-dataset-modal-btn');
    
    // Selected images for dataset splitting
    let selectedDatasetImages = new Set();
    let currentSplitType = 'train'; // Default split type
    
    if (addToDatasetBtn) {
        addToDatasetBtn.addEventListener('click', () => {
            // Show the dataset split modal
            if (datasetSplitModal) {
                datasetSplitModal.style.display = 'flex';
                populateDatasetImageGrid();
                
                // Setup auto-split button after grid is populated
                setupAutoSplitFunctionality();
            }
        });
    }
    
    if (closeDatasetModalBtn) {
        closeDatasetModalBtn.addEventListener('click', () => {
            if (datasetSplitModal) {
                datasetSplitModal.style.display = 'none';
                selectedDatasetImages.clear();
            }
        });
    }
    
    // Handle split type selection buttons
    const splitButtons = document.querySelectorAll('.split-buttons.inline .split-btn');
    splitButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active class from all buttons
            splitButtons.forEach(b => b.classList.remove('active'));
            // Add active class to clicked button
            btn.classList.add('active');
            // Update current split type
            currentSplitType = btn.dataset.split;
        });
    });
    
    // Handle select all/none buttons
    const selectAllBtn = document.getElementById('select-all-btn');
    const deselectAllBtn = document.getElementById('deselect-all-btn');
    const selectAnnotatedBtn = document.getElementById('select-annotated-btn');
    const selectUnannotatedBtn = document.getElementById('select-unannotated-btn');
    
    if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
            const allImageItems = document.querySelectorAll('.dataset-image-item');
            allImageItems.forEach(item => {
                item.classList.add('selected');
                selectedDatasetImages.add(item.dataset.imageId);
            });
            updateSelectedCount();
        });
    }
    
    if (deselectAllBtn) {
        deselectAllBtn.addEventListener('click', () => {
            const allImageItems = document.querySelectorAll('.dataset-image-item');
            allImageItems.forEach(item => {
                item.classList.remove('selected');
            });
            selectedDatasetImages.clear();
            updateSelectedCount();
        });
    }
    
    if (selectAnnotatedBtn) {
        selectAnnotatedBtn.addEventListener('click', () => {
            const annotatedItems = document.querySelectorAll('.dataset-image-item[data-has-annotations="true"]');
            annotatedItems.forEach(item => {
                item.classList.add('selected');
                selectedDatasetImages.add(item.dataset.imageId);
            });
            updateSelectedCount();
        });
    }
    
    if (selectUnannotatedBtn) {
        selectUnannotatedBtn.addEventListener('click', () => {
            const unannotatedItems = document.querySelectorAll('.dataset-image-item[data-has-annotations="false"]');
            unannotatedItems.forEach(item => {
                item.classList.add('selected');
                selectedDatasetImages.add(item.dataset.imageId);
            });
            updateSelectedCount();
        });
    }
    
    // Apply split button
    const applySplitBtn = document.getElementById('apply-split-btn');
    if (applySplitBtn) {
        applySplitBtn.addEventListener('click', () => {
            applyDatasetSplit();
        });
    }
    
    // Populate the dataset image grid
    function populateDatasetImageGrid() {
        const datasetImageGrid = document.querySelector('.dataset-image-grid');
        if (!datasetImageGrid) return;
        
        // Clear the grid
        datasetImageGrid.innerHTML = '';
        selectedDatasetImages.clear();
        
        // Get all image cards and create dataset image items
        const allImages = [];
        
        imageCards.forEach(card => {
            const imageId = card.dataset.imageId;
            const imageSrc = card.querySelector('img').src;
            const filename = card.querySelector('.image-filename').textContent;
            const hasAnnotations = card.querySelector('.status-badge.annotated') !== null;
            const currentSplit = card.querySelector('.split-badge')?.dataset.split;
            
            allImages.push({
                id: imageId,
                src: imageSrc,
                filename: filename,
                hasAnnotations: hasAnnotations,
                currentSplit: currentSplit
            });
        });
        
        // Update total count
        const totalCountEl = document.getElementById('total-count');
        if (totalCountEl) {
            totalCountEl.textContent = allImages.length;
        }
        
        // Create and append image items to grid
        allImages.forEach(image => {
            const imageItem = document.createElement('div');
            imageItem.className = 'dataset-image-item';
            if (image.currentSplit) {
                imageItem.classList.add(image.currentSplit);
            }
            imageItem.dataset.imageId = image.id;
            imageItem.dataset.hasAnnotations = image.hasAnnotations;
            
            let splitBadgeHtml = '';
            if (image.currentSplit) {
                const splitText = image.currentSplit.charAt(0).toUpperCase() + image.currentSplit.slice(1);
                splitBadgeHtml = `<div class="split-badge" data-split="${image.currentSplit}">${splitText}</div>`;
            }
            
            imageItem.innerHTML = `
                ${splitBadgeHtml}
                <img src="${image.src}" alt="${image.filename}">
                <div class="dataset-image-info">
                    ${image.filename}
                    ${image.hasAnnotations ? '<span class="annotation-badge"><i class="fas fa-check-circle"></i></span>' : ''}
                </div>
            `;
            
            // Add click event to toggle selection
            imageItem.addEventListener('click', () => {
                imageItem.classList.toggle('selected');
                if (imageItem.classList.contains('selected')) {
                    selectedDatasetImages.add(image.id);
                } else {
                    selectedDatasetImages.delete(image.id);
                }
                updateSelectedCount();
            });
            
            datasetImageGrid.appendChild(imageItem);
        });
    }
    
    // Update the selected count display
    function updateSelectedCount() {
        const selectedCountEl = document.getElementById('selected-count');
        if (selectedCountEl) {
            selectedCountEl.textContent = selectedDatasetImages.size;
        }
    }
    
    // Update selection button handlers
    if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
            const allImageItems = document.querySelectorAll('.dataset-image-item');
            allImageItems.forEach(item => {
                item.classList.add('selected');
                selectedDatasetImages.add(item.dataset.imageId);
            });
            updateSelectedCount();
        });
    }
    
    if (deselectAllBtn) {
        deselectAllBtn.addEventListener('click', () => {
            const allImageItems = document.querySelectorAll('.dataset-image-item');
            allImageItems.forEach(item => {
                item.classList.remove('selected');
            });
            selectedDatasetImages.clear();
            updateSelectedCount();
        });
    }
    
    if (selectAnnotatedBtn) {
        selectAnnotatedBtn.addEventListener('click', () => {
            const annotatedItems = document.querySelectorAll('.dataset-image-item[data-has-annotations="true"]');
            annotatedItems.forEach(item => {
                item.classList.add('selected');
                selectedDatasetImages.add(item.dataset.imageId);
            });
            updateSelectedCount();
        });
    }
    
    if (selectUnannotatedBtn) {
        selectUnannotatedBtn.addEventListener('click', () => {
            const unannotatedItems = document.querySelectorAll('.dataset-image-item[data-has-annotations="false"]');
            unannotatedItems.forEach(item => {
                item.classList.add('selected');
                selectedDatasetImages.add(item.dataset.imageId);
            });
            updateSelectedCount();
        });
    }
    
    // Apply the dataset split to selected images
    function applyDatasetSplit() {
        if (selectedDatasetImages.size === 0) {
            alert('Please select at least one image to add to the dataset split.');
            return;
        }
        
        // Create an array of promises, one for each image update
        const updatePromises = Array.from(selectedDatasetImages).map(imageId => {
            return fetch(`/api/images/${imageId}/split`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ split: currentSplitType })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to update image ${imageId}`);
                }
                return response.json();
            });
        });
        
        // Show loading indicator
        const originalBtnText = applySplitBtn.innerHTML;
        applySplitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Applying...';
        applySplitBtn.disabled = true;
        
        // Process all updates
        Promise.all(updatePromises)
            .then(results => {
                console.log('All images updated successfully', results);
                
                // Update UI to reflect the changes
                selectedDatasetImages.forEach(imageId => {
                    // Update the image item in the modal
                    const modalItem = document.querySelector(`.dataset-image-item[data-image-id="${imageId}"]`);
                    if (modalItem) {
                        // Remove any existing split classes
                        modalItem.classList.remove('train', 'val', 'test');
                        // Add the new split class
                        modalItem.classList.add(currentSplitType);
                        
                        // Update the split badge
                        let splitBadge = modalItem.querySelector('.split-badge');
                        const splitText = currentSplitType.charAt(0).toUpperCase() + currentSplitType.slice(1);
                        
                        if (!splitBadge) {
                            splitBadge = document.createElement('div');
                            splitBadge.className = 'split-badge';
                            modalItem.appendChild(splitBadge);
                        }
                        
                        splitBadge.dataset.split = currentSplitType;
                        splitBadge.textContent = splitText;
                    }
                    
                    // Update the image card in the main grid
                    const imageCard = document.querySelector(`.image-card[data-image-id="${imageId}"]`);
                    if (imageCard) {
                        const metaDiv = imageCard.querySelector('.image-meta div');
                        let splitBadge = imageCard.querySelector('.split-badge');
                        const splitText = currentSplitType.charAt(0).toUpperCase() + currentSplitType.slice(1);
                        
                        if (!splitBadge && metaDiv) {
                            splitBadge = document.createElement('span');
                            splitBadge.className = 'split-badge';
                            metaDiv.appendChild(splitBadge);
                        }
                        
                        if (splitBadge) {
                            splitBadge.dataset.split = currentSplitType;
                            splitBadge.textContent = splitText;
                        }
                    }
                });
                
                // Show success message
                alert(`Successfully added ${selectedDatasetImages.size} images to the ${currentSplitType} split.`);
                
                // Clear selection
                selectedDatasetImages.clear();
                document.querySelectorAll('.dataset-image-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });
            })
            .catch(error => {
                console.error('Error updating images:', error);
                alert('An error occurred while updating the images. Please try again.');
            })
            .finally(() => {
                // Reset button
                applySplitBtn.innerHTML = originalBtnText;
                applySplitBtn.disabled = false;
            });
    }
    
    // Auto-split functionality
    const autoSplitBtn = document.getElementById('auto-split-btn');
    if (autoSplitBtn) {
        console.log("Found auto-split button, adding click handler");
        autoSplitBtn.addEventListener('click', function() {
            console.log("Auto-split button clicked");
            if (!confirm('This will automatically assign all images to train/validation/test splits. Continue?')) {
                return;
            }
            
            // Get all image items
            const allImageItems = document.querySelectorAll('.dataset-image-grid .dataset-image-item');
            console.log(`Found ${allImageItems.length} images to auto-split`);
            
            if (allImageItems.length === 0) {
                alert("No images found to split. Please make sure images are loaded in the grid.");
                return;
            }
            
            // Randomly shuffle the images
            const shuffledImages = Array.from(allImageItems);
            for (let i = shuffledImages.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledImages[i], shuffledImages[j]] = [shuffledImages[j], shuffledImages[i]];
            }
            console.log("Images shuffled for random distribution");
            
            // Calculate split counts
            const totalCount = shuffledImages.length;
            const trainCount = Math.round(totalCount * 0.7);  // 70% for training
            const valCount = Math.round(totalCount * 0.2);    // 20% for validation
            // rest goes to test set
            
            console.log(`Split calculation: Total=${totalCount}, Train=${trainCount}, Val=${valCount}, Test=${totalCount - trainCount - valCount}`);
            
            // Create arrays for each split
            const trainImages = shuffledImages.slice(0, trainCount);
            const valImages = shuffledImages.slice(trainCount, trainCount + valCount);
            const testImages = shuffledImages.slice(trainCount + valCount);
            
            // Show loading indicator
            const originalBtnText = autoSplitBtn.innerHTML;
            autoSplitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Splitting...';
            autoSplitBtn.disabled = true;
            
            // Apply each split in sequence
            console.log("Starting to apply auto-split...");
            Promise.resolve()
                .then(() => {
                    console.log(`Applying train split to ${trainImages.length} images`);
                    return applyAutoSplit(trainImages, 'train');
                })
                .then(() => {
                    console.log(`Applying validation split to ${valImages.length} images`);
                    return applyAutoSplit(valImages, 'val');
                })
                .then(() => {
                    console.log(`Applying test split to ${testImages.length} images`);
                    return applyAutoSplit(testImages, 'test');
                })
                .then(() => {
                    // Show success message
                    console.log("Auto-split completed successfully");
                    alert(`Auto-split complete! Images distributed as:\n- Training: ${trainImages.length}\n- Validation: ${valImages.length}\n- Testing: ${testImages.length}`);
                })
                .catch(error => {
                    console.error('Error in auto-split:', error);
                    alert('An error occurred during auto-split. Please try again.');
                })
                .finally(() => {
                    // Reset button
                    autoSplitBtn.innerHTML = originalBtnText;
                    autoSplitBtn.disabled = false;
                });
        });
    } else {
        console.error("Auto-split button not found in the DOM");
    }
    
    // Helper function to apply split to a batch of images
    function applyAutoSplit(images, splitType) {
        if (!images || images.length === 0) {
            console.log(`No images to apply ${splitType} split`);
            return Promise.resolve();
        }
        
        console.log(`Applying ${splitType} split to ${images.length} images`);
        
        // Collect all image IDs from this batch
        const imageIds = images.map(img => img.dataset.imageId);
        console.log("Image IDs for batch:", imageIds);
        
        // Create batch update requests
        const updatePromises = imageIds.map(imageId => {
            console.log(`Sending request to update image ${imageId} to ${splitType}`);
            return fetch(`/api/images/${imageId}/split`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ split: splitType })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to update image ${imageId}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log(`Successfully updated image ${imageId} to ${splitType}:`, data);
                return data;
            });
        });
        
        // Process all updates and update UI
        return Promise.all(updatePromises)
            .then(results => {
                console.log(`All ${splitType} updates complete:`, results);
                
                // Update UI to reflect the changes
                images.forEach(imageItem => {
                    const imageId = imageItem.dataset.imageId;
                    
                    // Update the image item in the modal
                    imageItem.classList.remove('train', 'val', 'test');
                    imageItem.classList.add(splitType);
                    
                    // Update the split badge
                    let splitBadge = imageItem.querySelector('.split-badge');
                    const splitText = splitType.charAt(0).toUpperCase() + splitType.slice(1);
                    
                    if (!splitBadge) {
                        splitBadge = document.createElement('div');
                        splitBadge.className = 'split-badge';
                        imageItem.appendChild(splitBadge);
                    }
                    
                    splitBadge.dataset.split = splitType;
                    splitBadge.textContent = splitText;
                    
                    // Update the image card in the main grid
                    const imageCard = document.querySelector(`.image-card[data-image-id="${imageId}"]`);
                    if (imageCard) {
                        const metaDiv = imageCard.querySelector('.image-meta div');
                        let cardSplitBadge = imageCard.querySelector('.split-badge');
                        
                        if (!cardSplitBadge && metaDiv) {
                            cardSplitBadge = document.createElement('span');
                            cardSplitBadge.className = 'split-badge';
                            metaDiv.appendChild(cardSplitBadge);
                        }
                        
                        if (cardSplitBadge) {
                            cardSplitBadge.dataset.split = splitType;
                            cardSplitBadge.textContent = splitText;
                        }
                    }
                });
                
                return results;
            });
    }
    
    // Make sure all dataset split functionality runs when Add to Dataset button is clicked
    if (addToDatasetBtn) {
        addToDatasetBtn.addEventListener('click', () => {
            // Show the dataset split modal
            if (datasetSplitModal) {
                datasetSplitModal.style.display = 'flex';
                populateDatasetImageGrid();
                
                // Setup auto-split button after grid is populated
                setupAutoSplitFunctionality();
            }
        });
    }
    
    function setupAutoSplitFunctionality() {
        console.log("Setting up auto-split functionality");
        const autoSplitBtn = document.getElementById('auto-split-btn');
        if (autoSplitBtn) {
            // Remove any existing event listeners
            autoSplitBtn.replaceWith(autoSplitBtn.cloneNode(true));
            
            // Get fresh reference after cloning
            const freshAutoSplitBtn = document.getElementById('auto-split-btn');
            
            console.log("Adding click handler to auto-split button");
            freshAutoSplitBtn.addEventListener('click', function() {
                console.log("Auto-split button clicked");
                if (!confirm('This will automatically assign all images to train/validation/test splits. Continue?')) {
                    return;
                }
                
                // Get all image items
                const allImageItems = document.querySelectorAll('.dataset-image-grid .dataset-image-item');
                console.log(`Found ${allImageItems.length} images to auto-split`);
                
                if (allImageItems.length === 0) {
                    alert("No images found to split. Please make sure images are loaded in the grid.");
                    return;
                }
                
                // Randomly shuffle the images
                const shuffledImages = Array.from(allImageItems);
                for (let i = shuffledImages.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledImages[i], shuffledImages[j]] = [shuffledImages[j], shuffledImages[i]];
                }
                console.log("Images shuffled for random distribution");
                
                // Calculate split counts
                const totalCount = shuffledImages.length;
                const trainCount = Math.round(totalCount * 0.7);  // 70% for training
                const valCount = Math.round(totalCount * 0.2);    // 20% for validation
                // rest goes to test set
                
                console.log(`Split calculation: Total=${totalCount}, Train=${trainCount}, Val=${valCount}, Test=${totalCount - trainCount - valCount}`);
                
                // Create arrays for each split
                const trainImages = shuffledImages.slice(0, trainCount);
                const valImages = shuffledImages.slice(trainCount, trainCount + valCount);
                const testImages = shuffledImages.slice(trainCount + valCount);
                
                // Show loading indicator
                const originalBtnText = freshAutoSplitBtn.innerHTML;
                freshAutoSplitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Splitting...';
                freshAutoSplitBtn.disabled = true;
                
                // Apply each split in sequence
                console.log("Starting to apply auto-split...");
                Promise.resolve()
                    .then(() => {
                        console.log(`Applying train split to ${trainImages.length} images`);
                        return applyAutoSplit(trainImages, 'train');
                    })
                    .then(() => {
                        console.log(`Applying validation split to ${valImages.length} images`);
                        return applyAutoSplit(valImages, 'val');
                    })
                    .then(() => {
                        console.log(`Applying test split to ${testImages.length} images`);
                        return applyAutoSplit(testImages, 'test');
                    })
                    .then(() => {
                        // Show success message
                        console.log("Auto-split completed successfully");
                        alert(`Auto-split complete! Images distributed as:\n- Training: ${trainImages.length}\n- Validation: ${valImages.length}\n- Testing: ${testImages.length}`);
                    })
                    .catch(error => {
                        console.error('Error in auto-split:', error);
                        alert('An error occurred during auto-split. Please try again.');
                    })
                    .finally(() => {
                        // Reset button
                        freshAutoSplitBtn.innerHTML = originalBtnText;
                        freshAutoSplitBtn.disabled = false;
                    });
            });
        } else {
            console.error("Auto-split button not found in the DOM");
        }
    }
});
</script>
{% endblock %}

{% block custom_scripts %}
<script>
    // Global variables and main code setup
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize variables
        // ... existing code ...
        
        // Initialize dataset split buttons
        initializeDatasetSplitButtons();
        
        // Disable pinch zoom and other zoom gestures
        disableAutoZoom();
        
        // Initialize AI labeling in canvas
        initializeAiLabeling();
        
        // ... existing code ...
    });
    
    // ... existing functions ...
    
    // Initialize AI labeling in canvas
    function initializeAiLabeling() {
        // Variables for AI labeling
        const aiLabelToggle = document.getElementById('ai-label-toggle');
        const aiLabelingPanel = document.getElementById('ai-labeling-panel');
        const canvasAiMode = document.getElementById('canvas-ai-mode');
        const canvasAiConfidence = document.getElementById('canvas-ai-confidence');
        const canvasConfidenceValue = document.getElementById('canvas-confidence-value');
        const useCustomClasses = document.getElementById('use-custom-classes');
        const canvasCustomClasses = document.getElementById('canvas-custom-classes');
        const canvasAiScope = document.getElementById('canvas-ai-scope');
        const runCanvasAi = document.getElementById('run-canvas-ai');
        const aiProcessingStatus = document.getElementById('ai-processing-status');
        const batchProgressBar = document.getElementById('batch-progress-bar');
        const batchProgressCount = document.getElementById('batch-progress-count');
        
        if (!aiLabelToggle || !aiLabelingPanel) {
            console.error('AI labeling elements not found in DOM');
            return;
        }
        
        // Toggle AI labeling panel
        aiLabelToggle.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('AI Label Toggle clicked');
            console.log('Current panel visibility:', aiLabelingPanel.style.display);
            
            // Toggle using more reliable approach
            if (aiLabelingPanel.style.display === 'none' || aiLabelingPanel.style.display === '') {
                aiLabelingPanel.style.display = 'block';
                aiLabelingPanel.classList.add('visible');
            } else {
                aiLabelingPanel.style.display = 'none';
                aiLabelingPanel.classList.remove('visible');
            }
            
            console.log('New panel visibility:', aiLabelingPanel.style.display);
            console.log('Panel classList:', aiLabelingPanel.classList);
        });
        
        // Update confidence value display
        canvasAiConfidence.addEventListener('input', function() {
            canvasConfidenceValue.textContent = this.value;
        });
        
        // Toggle custom classes textarea
        useCustomClasses.addEventListener('change', function() {
            canvasCustomClasses.disabled = !this.checked;
        });
        
        // Update button text based on selected mode and scope
        function updateButtonText() {
            const mode = canvasAiMode.value;
            const scope = canvasAiScope.value;
            
            let buttonText = mode === 'detect' ? 'Detect Objects' : 'Classify Images';
            if (scope !== 'current') {
                buttonText += ` (${scope === 'all' ? 'All' : 'Unannotated'})`;
            }
            
            runCanvasAi.innerHTML = `<i class="fas fa-magic"></i> ${buttonText}`;
        }
        
        canvasAiMode.addEventListener('change', updateButtonText);
        canvasAiScope.addEventListener('change', updateButtonText);
        
        // Initial button text setup
        updateButtonText();
        
        // Run AI labeling on selected images
        runCanvasAi.addEventListener('click', function() {
            // ... existing code ...
        });
    }
    
    // ... existing functions ...
    
    // Setup dataset split buttons
    function initializeDatasetSplitButtons() {
                return;
            }
            
            // Use the batch API
            fetch(`/api/projects/${projectId}/batch_label`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    image_ids: imageIds,
                    mode: mode,
                    threshold: confidence,
                    class_names: classNames,
                    replace_existing: true
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API responded with status ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Update UI
                if (data.status === 'success') {
                    // Reload annotations for current image
                    const currentImageId = getCurrentImageId();
                    if (currentImageId && imageIds.includes(Number(currentImageId))) {
                        refreshCurrentImageAnnotations(currentImageId);
                    }
                    
                    // Update status badges for all images
                    data.results.forEach(result => {
                        if (result.status === 'success') {
                            updateImageCardStatus(result.image_id, true);
                        }
                    });
                    
                    showNotification(`Successfully processed ${data.processed} of ${data.total} images`, 'success');
                } else {
                    showNotification(`Error: ${data.message || 'Unknown error'}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error during batch processing:', error);
                showNotification('Error processing request: ' + error.message, 'error');
            })
            .finally(() => {
                // Reset UI
                hideProcessingIndicator();
                aiProcessingStatus.style.display = 'none';
                runCanvasAi.disabled = false;
                updateButtonText();
            });
            
            return;
        }
        
        // Process images one by one for small batches
        let processed = 0;
        let successful = 0;
        
        function processNextImage() {
            if (processed >= imageIds.length) {
                // All done
                runCanvasAi.disabled = false;
                updateButtonText();
                aiProcessingStatus.style.display = 'none';
                hideProcessingIndicator();
                
                showNotification(`Completed processing ${successful} of ${imageIds.length} images`, 'success');
                return;
            }
            
            const imageId = imageIds[processed];
            
            // Update progress
            if (imageIds.length > 1) {
                batchProgressCount.textContent = `${processed}/${imageIds.length}`;
                batchProgressBar.style.width = `${(processed / imageIds.length) * 100}%`;
            }
            
            // Determine which API endpoint to use
            const endpoint = mode === 'detect' ? 
                `/api/images/${imageId}/zero_shot_detect` : 
                `/api/images/${imageId}/zero_shot_classify`;
            
            // Call API
            fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    threshold: confidence,
                    class_names: classNames,
                    create_annotations: true,
                    replace_existing: true
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API responded with status ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    successful++;
                    
                    // Update UI for the current image
                    if (imageId === getCurrentImageId()) {
                        refreshCurrentImageAnnotations(imageId);
                    }
                    
                    // Update status badge for this image
                    updateImageCardStatus(imageId, true);
                } else {
                    console.error(`Error processing image ${imageId}:`, data.message);
                }
            })
            .catch(error => {
                console.error(`Error processing image ${imageId}:`, error);
            })
            .finally(() => {
                // Process next image
                processed++;
                setTimeout(processNextImage, 100); // Small delay to prevent overwhelming the server
            });
        }
        
        // Start processing
        processNextImage();
    }
    
    // Helper function to refresh annotations for current image
    function refreshCurrentImageAnnotations(imageId) {
        fetch(`/api/images/${imageId}/annotations`)
            .then(response => response.json())
            .then(annotData => {
                if (annotData.annotations) {
                    // Clear existing annotations
                    if (typeof clearAnnotations === 'function') {
                        clearAnnotations();
                    }
                    
                    // Populate annotations list
                    const annotationsList = document.getElementById('annotations-list');
                    if (annotationsList) {
                        annotationsList.innerHTML = '';
                        annotData.annotations.forEach(ann => {
                            if (typeof addAnnotationToList === 'function') {
                                addAnnotationToList(ann);
                            } else if (typeof addAnnotation === 'function') {
                                addAnnotation(ann);
                            }
                        });
                    }
                    
                    // Draw annotations on canvas
                    if (typeof drawAnnotations === 'function') {
                        drawAnnotations(annotData.annotations);
                    } else if (typeof refreshCanvas === 'function') {
                        refreshCanvas();
                    }
                }
            });
    }
    
    // Helper function to get project ID
    function getProjectId() {
        // Method 1: Check URL path
        const urlPath = window.location.pathname;
        const projectMatch = urlPath.match(/\/projects\/(\d+)/);
        if (projectMatch && projectMatch[1]) {
            return projectMatch[1];
        }
        
        // Method 2: Check meta tag if exists
        const projectMeta = document.querySelector('meta[name="project-id"]');
        if (projectMeta && projectMeta.content) {
            return projectMeta.content;
        }
        
        // Method 3: Check for any data attribute in the DOM
        const projectElement = document.querySelector('[data-project-id]');
        if (projectElement && projectElement.dataset.projectId) {
            return projectElement.dataset.projectId;
        }
        
        return null;
    }
</script>
{% endblock %} 